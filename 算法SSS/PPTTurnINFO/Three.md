第3章

动态规划

1

20世纪50年代初美国数学家R.E.Bellman等
人在研究多阶段决策过程(multistep decision
process)的优化问题时，提出了著名的最优化
原理(principle of optimality)，把多阶段过程转
化为一系列单阶段问题，逐个求解，创立了解
决这类过程优化问题的新方法——动态规划。

2

动态规划问世以来，在经济管理、生产调度、工
程技术和最优控制等方面得到了广泛的应用。
最短路线
库存管理
资源分配
设备更新
排序
装载等问题
用动态规划方法比用其它方法求解更为方便。

3

多阶段决策过程
• N个输入的最优解问题，其活动过程往往划分
为若干阶段，每一阶段决策依赖前一阶段状
态，由决策所采取的动作使状态发生转移，
成为下一阶段依据。
P1

S0

P2

S1

S2

….

Pn
Sn-1

Sn

4

最优性原理
• 贝尔曼(Richard Bellman):
– 无论过程的初态和初始决策是什么，其余的决策
都必须相对于初始决策所产生的状态，构成一个
最优决策序列。
– 决策每一阶段，都有可能由多种决策可供选取，
其中只有一种决策对全局是最优的。
5

最优性原理
假定对一种状态可以作出多种决策，而每一种决策可以产生
一种新状态，根据最优原理：
• 对初态S0， P1={p1,1, p1,2,…., p1,r1}是可能的决策值集合，由它
产生状态：S1={S1,1, S1,2,…., S1,r1}。决策值集合作为阶段子问
题保存。
• 依此类推：
对状态Sn-1={Sn-1,1, Sn-1,2,…., Sn-1,rn-1}是可能的决策集合:
Pn={Pn-1,1, Pn-1,2,….,Pn-1,rn-1 }
• 其中只有一种状态是最优，假定是Sn,kn ,它由决策Pn,kn产生，
故Pn,kn为最优决策。
6

最优性原理
假定Pn,kn是依据Sn-1,kn-1作出，由此回溯：
Sn-1,kn-1的决策Pn-1,kn-1是最优决策。
一直回溯到P1,k1, 可得最优决策序列：
{P1,k1, P2,k2 …,Pn, kn},
导致状态转移序列：
{S0,S1,k1, S2,k2 …,Sn,kn}
最优决策由最后阶段形成，然后向前倒推，直到初始阶段；
决策的具体结果及产生的状态转移，由初始阶段计算，然
后向后递归或迭代，直到最终结果。
7

动态规划函数
• 决策过程中，有一个赖以决策的策略或目标，
这个策略或目标称之为决策函数。
• 整个决策过程可以递归进行，或用循环迭代
的方法进行。

8

货郎担问题
对n个城市，用1～n编号，问题归结为：
在有向赋权图G=<V, E>中，寻找一条路径最短的哈密尔顿
回路问题。
其中：V={1,2,…,n}表示城市顶点，
边(i,j) ∈E表示城市i到城市j的距离。
用邻接矩阵C表示各城市间距离：
如果(i,j) ∈E，则Cij>0且Cij是fixed，否则Cij=∞。
令：d(i,V’)表示从定点i出发，经过V’中各个顶点一次，
最终回到i的最短路径长度。
初始时，令V’=V-{i}

9

货郎担问题
定义动态规划函数:

假定4个城市费用矩阵

∞ 3
5 ∞
6 4
3 7

6
2
∞
5

7
3
2
∞

则最短路径长度为：
d(1,{2,3,4}}=min{
c12+d(2,{3,4}),
}

c13+d(3,{2,4}),

c14+d(4,{2,3})
10

货郎担问题
上阶段决策，依赖下列计算结果：
d(2,{3,4})=min{(c23+d(3,{4}), c24+d(4,{3})}
d(3,{2,4})=min{(c32+d(2,{4}), c34+d(4,{2})}
d(4,{2,3})=min{(c42+d(2,{3}), c43+d(3,{2})}
上阶段决策，依赖下列计算结果：
d(3,{4}), d(4,{3},d(2,{4}), d(4,{2}),d(2,{3}), d(3,{2})
再向前推：
d(3,{4})=c34+c41=2+3=5
d(4,{3})=c43+c31=5+6=11
d(2,{4})=c24+c41=3+3=6
d(4,{2})=c42+c21=7+5=12
d(2,{3})=c23+c31=2+6=8
d(3,{2})=c32+c21=4+5=9
11

据上结果，再向后计算：
d(2,{3,4})=min{2＋5，3＋11}＝7 路径顺序：2，3，4，1
d(3,{2,4})=min{4+6,2+12}＝10
路径顺序：3，2，4，1
d(4,{2,3})=min{7＋8，5＋9}＝14 路径顺序：4，2，3，1
最后：d(1,{2,3,4})=min{3+7,6+10,7+14}=10
d(1,{2,3,4})

d(2,{3,4})

d(3,{4}) d(4,{3})

d(3,{2,4})

d(4,{2,3})

d(2,{4}) d(4,{2}) d(2,{3}) d(3,{2})

d(4,φ) d(3,φ)
d(4,φ)
d(2,φ)
d(3,φ) d(2,φ)
同样方法可以分别计算从2、3、4出发，经其他城市回到2、3、4的最短路径。
最终选择一条最短路径。
12

实际中很多问题都可以归结为货郎担这类问题.
如:
1.物资运输路线中,汽车应该走怎样的路线使路程最短;
2.工厂里在钢板上要挖一些小圆孔,自动焊接机的割咀应走怎样的路线使路
程最短;
3.城市里有一些地方铺设管道时,管子应走怎样的路线才能使管子耗费最少；
4. 旅行社选择哪条线路？

13

货郎担问题
令ni是计算从顶点i出发返回顶点所需计算形式为d(k,V-{k})的个数, k!=i。
开始计算d(i,V-{i})时，集合V-{i}中有n-1个城市。
以后计算d(k,V-{k})时，集合V-{k}城市数目在不同决策阶段，分别为

n-2,n-3,…,0。
整个计算中，计算大小为j的不同城市的集合个数为

,, j=0,1,…,n-1

则：
当V-{k}集合中城市个数为j时，为了计算d(k,V-{k})，需要进行j次加法运
算和j-1次比较运算。

14

总运算时间为Ti:

由二项式定理：

令x=y=1，可得：

动态规划将问题转换称组合问题，降
低了算法时间复杂度。
15

算法总体思想
• 动态规划算法与分治法类似，其基本思想也是将待求
解问题分解成若干个子问题；但是经分解得到的子问
题往往不是互相独立的。不同子问题的数目常常只有
多项式量级。
• 在用分治法求解时，有些子问题被重复计算了许多次。

T(n)

=

T(n/4)

T(n/4)

n

T(n/4)

T(n/4)
16

算法总体思想
• 如果能够保存已解决的子问题的答案，而在需要时再
找出已求得的答案，就可以避免大量重复计算，从而
得到多项式时间算法。

n the past are doomed to
=
Those
who
cannot
remember
T(n)
repeat it.
n/2
T(n/4)

T(n/4)

n/2
T(n/4)

T(n/4)

-----George Santayana,
The life of Reason,
n/2 Book I: Introduction
n/2and
Reason in Common
Sense (1905)

T(n/4) T(n/4) T(n/4)T(n/4)T(n/4) T(n/4) 17T(n/4)

动态规划基本步骤
• 找出最优解的性质，并刻划其结构特征。
• 递归地定义最优值（建立递归关系）。
• 以自底向上的方式计算出最优值。
• 根据计算最优值时得到的信息，构造最优
解。

18

矩阵连乘问题


问题描述：给定n个矩阵 {A1 , A2 ,..., An }，其中 Ai 与 Ai 1
是可乘的，i=1,2,…,n-1。考察这n个矩阵的连乘积

A1 A2 ... An




由于矩阵乘法满足结合律，所以计算矩阵的连乘可以
有许多不同的计算次序。这种计算次序可以用加括号
的方式来确定。
若一个矩阵连乘积的计算次序完全确定，也就是说该
连乘积已完全加括号，则可以依此次序反复调用2个矩
阵相乘的标准算法计算出矩阵连乘积。

19

完全加括号的矩阵连乘积


完全加括号的矩阵连乘积可递归地定义为：
（1）单个矩阵是完全加括号的；
（2）矩阵连乘积 A 是完全加括号的，则 A 可
表示为2个完全加括号的矩阵连乘积 B 和 C
的乘积并加括号，即 A  (BC )



设有四个矩阵

A, B, C, D ，它们的维数分别是：

A  50 10 B  10  40 C  40 30 D  30 5


总共有五中完全加括号的方式

( A(( BC ) D ))
((( AB )C ) D )

( A( B(CD)))
(( A( BC )) D )

(( AB )(CD))

16000, 10500, 36000, 87500, 34500

20

矩阵连乘问题
问题描述：给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘
的，i=1,2 ,…,n-1, 设Ai的维数为 pi 1  pi 。如何确定计算矩阵
连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数
乘次数最少。
穷举法：列举出所有可能的计算次序，并计算出每一种计
算次序相应需要的数乘次数，从中找出一种数乘次数最少的
计算次序。
算法复杂度分析：
对于n个矩阵的连乘积，设其不同的计算次序为P(n)。
由于每种加括号方式都可以分解为两个子矩阵的加括号问题：
(A1...Ak)(Ak+1…An)可以得到关于P(n)的递推式如下：
1

n 1
 n 1
n
3/ 2
P ( n)  

P
(
n
)


(
4
/
n
)
P(k ) P(n  k ) n  1


 k 1

21

矩阵连乘问题
动态规划
将矩阵连乘积 Ai Ai 1... A j ,简记为A[i:j] ，这里i≤j.
考察计算A[i:j]的最优计算次序。
分析：设这个计算次序在矩阵Ak和Ak+1之间将矩阵链断开，
i≤k<j，则其相应完全加括号方式为：

( Ai Ai 1... Ak )( Ak 1 Ak  2 ... A j )
计算量：A[i:k]的计算量加上A[k+1:j]的计算量，再加上
A[i:k]和A[k+1:j]相乘的计算量
22

分析最优解的结构
• 特征：计算A[i:j]的最优次序所包含的计算矩阵
子链 A[i:k]和A[k+1:j]的次序也是最优的。
• 矩阵连乘计算次序问题的最优解包含着其子问
题的最优解。这种性质称为最优子结构性质。
• 问题的最优子结构性质是该问题可用动态规划
算法求解的显著特征。

23

建立递归关系





设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i][j].
当i=j时，A[i:j]=Ai，因此，m[i][i]=0，i=1,2,…,n
当i<j时，

m[i ][ j ]  m[i ][ k ]  m[k  1][ j ]  pi 1 pk p j



这里 Ai 的维数为 pi 1  pi
可以递归地定义m[i][j]为：

0
i j


m[i][ j ]  
min {m[i][ k ]  m[k  1][ j ]  pi 1 pk p j } i  j

 ik  j
k 的位置只有 j  i 种可能
24

计算最优值


对于1≤i≤j≤n不同的有序对(i, j)对应于不同的子问题。
因此，不同子问题的个数最多只有

 n
   n  ( n 2 )
 2




由此可见，在递归计算时，许多子问题被重复计算多
次。这也是该问题可用动态规划算法求解的又一显著
特征。
用动态规划算法解此问题，可依据其递归式以自底向
上的方式进行计算。在计算过程中，保存已解决的子
问题答案。每个子问题只计算一次，而在后面需要时
只要简单查一下，从而避免大量的重复计算，最终得
到多项式时间的算法。
25

计算最优值
输入量：p0, p1,…pn
m[i][j]存放所需要的最少数乘次数
s[i][j]存放所需要的最少数乘次数的分隔位置

0
i j


m[i][ j ]  
min {m[i][ k ]  m[k  1][ j ]  pi 1 pk p j } i  j

 ik  j
自底向上顺序计算m[i][j]
m[1][2]
m[2][3],m[1][3]
m[3][4],m[2][4],m[1][4]
………
m[n-1][n],… … … m[1][n]

26

用动态规划法求最优解
public static void matrixChain(int [] p, int [][] m, int [][] s)
{

A1
int n=p.length-1;

A2

A3

A4

A5

A6

3035 3515 155 510 1020 2025

for (int i = 1; i <= n; i++) m[i][i] = 0;

 m[2][ 2]  m[3][5]  p1 p2 p5  0  2500  35 15  20  13000

for (int r = 2; r <= n; r++)
m[2][5]  min m[2][3]  m[4][5]  p1 p3 p5  2625  1000  35  5  20  7125
 m[2][ 4]  m[5][5]  p p p  4375  0  35 10  20  11375
for (int i = 1; i <= n - r+1; i++) {
1 4 5


算法复杂度分析：
m[i][j] = m[i+1][j]+ p[i-1]*p[i]*p[j]; 算法matrixChain的主要计算量取决于算法中对r，i
和k的3重循环。循环体内的计算量为O(1)，而3重
s[i][j] = i;
循环的总次数为O(n3)。因此算法的计算时间上界
为O(n3)。算法所占用的空间显然为O(n2)。
for (int k = i+1; k < j; k++) {
int j=i+r-1;

int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];
if (t < m[i][j]) {
m[i][j] = t;
s[i][j] = k;}
}
}
}

27

构造最优解
MatrixChain已经记录了构造最优解所需全部信息。
由s[1][n]可知计算A[1:n]的最优加括号方式为：
(A[1:s[1][n])(A[s[1][n]+1:n])
构造最优解的算法：
public void Traceback(int i,int j,int s[][])
{
if(i==j) return;
Traceback( i ,s[i][j] , s);
Traceback( s[i][j]+1 , j ,s);
system.out.println(<<“Multiply A[”+i<+“:”+<s[i][j]+
“]and A[”<<(s[i][j]+1)<<“:”+j+“]”);
}
求A[1:n]的最优解只需调用Traceback(1,n,s)。
28

动态规划算法的基本要素
一、最优子结构
•矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这
种性质称为最优子结构性质。
•在分析问题的最优子结构性质时，所用的方法具有普遍性：首
先假设由问题的最优解导出的子问题的解不是最优的，然后再
设法说明在这个假设下可构造出比原问题最优解更好的解，从
而导致矛盾。
•利用问题的最优子结构性质，以自底向上的方式递归地从子问
题的最优解逐步构造出整个问题的最优解。最优子结构是问题
能用动态规划算法求解的前提。
注意：同一个问题可以有多种方式刻划它的最优子结构，有些
表示方法的求解速度更快（空间占用小，问题的维度低）
29

二、重叠子问题
•递归算法求解问题时，每次产生的子问题并不总是新问题，有
些子问题被反复计算多次。这种性质称为子问题的重叠性质。
•动态规划算法，对每一个子问题只解一次，而后将其解保存在
一个表格中，当再次需要解此子问题时，只是简单地用常数时
间查看一下结果。
•通常不同的子问题个数随问题的大小呈多项式增长。因此用动
态规划算法只需多项式时间O(n3) ，从而获得较高的解题效率。

30

三、备忘录方法
•备忘录方法的控制结构与直接递归方法的控制结构相同，区别
在于备忘录方法为每个解过的子问题建立了备忘录以备需要时
查看，避免了相同子问题的重复求解。
m0
private static int lookupChain(int i, int j)
{
if (m[i][j] > 0) return m[i][j];//已计算过，返回子问题的最优值
if (i == j) return 0;
int u = lookupChain(i+1,j) + p[i-1]*p[i]*p[j];//u记录子问题的最优值
s[i][j] = i;//s记录子矩阵划分的位置
for (int k = i+1; k < j; k++) {
int t = lookupChain(i,k) + lookupChain(k+1,j) + p[i-1]*p[k]*p[j];
if (t < u) {
u = t; s[i][j] = k;}
}
m[i][j] = u;
return u;
}

31

最长公共子序列
• 定义1：若给定序列X={x1,x2,…,xm}，则另一序列Z={z1,z2,…,zk}
是X的子序列：是指存在一个严格递增下标序列{i1,i2,…,ik}使
得对于所有j=1,2,…,k有：zj=xij。
• 例如：序列Z={B，C，D，B}是序列X={A，B，C，B，D，
A，B}的子序列，相应的递增下标序列为{2，3，5，7}。
• 定义2：给定两个序列X和Y，当另一序列Z既是X的子序列又
是Y的子序列时，称Z是序列X和Y的公共子序列。
• 问题描述：给定两个序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}，
找出X和Y的最长公共子序列。
32

最长公共子序列的结构
设序列Xm={x1,x2,…,xm}和Yn={y1,y2,…,yn}的最长公共子序列为
Zk={z1,z2,…,zk} (k≤m, n )，则
(1)若xm=yn，则zk=xm=yn，且Zk-1是Xm-1和Yn-1的最长公共子序列。
(2)若xm≠yn且zk≠xm，则Zk是Xm-1和Yn的最长公共子序列。
(3)若xm≠yn且zk≠yn，则Zk是X和Yn-1的最长公共子序列。

由此可见，2个序列的最长公共子序列包含了这2个序列的前缀
的最长公共子序列。因此，最长公共子序列问题具有最优子结
构性质。
33

子问题的递归结构
由最长公共子序列问题的最优子结构性质建立子问题最优值
的递归关系。用c[i][j]记录序列Xi和Yj的最长公共子序列的长
度。其中， Xi={x1,x2,…,xi}；Yj={y1,y2,…,yj}。当i=0或j=0时，
空序列是Xi和Yj的最长公共子序列。故此时c[i][j]=0。其他情
况下，由最优子结构性质可建立递归关系如下：


0

c[i ][ j ]  
c[i  1][ j  1]  1
max{ c[i ][ j  1], c[i  1][ j ]}


i  0, j  0
i, j  0; xi  y j
i, j  0; xi  y j

34

计算最优值

由于在所考虑的子问题空间中，总共有θ(mn)个不同的子问题，
因此，用动态规划算法自底向上地计算最优值能提高算法的效率。
Algorithm lcsLength(x,y,b)
构造最长公共子序列
1: mx.length-1;
Algorithm lcs(int i,int j,char [] x,int [][] b)
2: ny.length-1;
{
3: c[i][0]=0; c[0][i]=0;
if (i ==0 || j==0) return;
4: for (int i = 1; i <= m; i++)
if (b[i][j]== 1){
5: for (int j = 1; j <= n; j++)
lcs(i-1,j-1,x,b);
6:
if (x[i]==y[j])
System.out.print(x[i]);
7:
c[i][j]=c[i-1][j-1]+1;
}
8:
b[i][j]=1;
else if (b[i][j]== 2) lcs(i-1,j,x,b);
9:
else if (c[i-1][j]>=c[i][j-1])
else lcs(i,j-1,x,b);
10:
c[i][j]=c[i-1][j];
}
11:
b[i][j]=2;
12: else
13:
c[i][j]=c[i][j-1];
35
14:
b[i][j]=3;

例如：序列X=(a, b, c, b, d, b)，Y=(a, c, b, b, a, b, d, b, b)，动态规
划法求解最长公共子序列的过程如下。

36

算法的改进
•在算法lcsLength和lcs中，可进一步将数组b省去。事
实上，数组元素c[i][j]的值仅由c[i-1][j-1]，c[i-1][j]和
c[i][j-1]这3个数组元素的值所确定。对于给定的数组
元素c[i][j]，可以不借助于数组b而仅借助于c本身在
时间内确定c[i][j]的值是由c[i-1][j-1],c[i-1][j]和c[i][j-1]
中哪一个值所确定的。
•如果只需要计算最长公共子序列的长度，则算法的空
间需求可大大减少。事实上，在计算c[i][j]时，只用
到数组c的第i行和第i-1行。因此，用2行的数组空间就
可以计算出最长公共子序列的长度。进一步的分析还
可将空间需求减至O(min(m,n))。
37

流水作业调度
问题描述：n个作业{1，2，…，n}要在由2台机器M1和M2组成
的流水线上完成加工。每个作业加工的顺序都是先在M1上加工，
然后在M2上加工。M1和M2加工作业i所需的时间分别为ai和bi。
流水作业调度问题要求确定这n个作业的最优加工顺序，使得
从第一个作业在机器M1上开始加工，到最后一个作业在机器
M2上加工完成所需的时间最少。
分析：
•直观上，一个最优调度应使机器M1没有空闲时间，且机器
M2的空闲时间最少。在一般情况下，机器M2上会有机器空闲
和作业积压2种情况。
•设全部作业的集合为N={1，2，…，n}。S N是N的作业子集。
在一般情况下，机器M1开始加工S中作业时，机器M2还在加
工其他作业，要等时间t后才可利用。将这种情况下完成S中作
业所需的最短时间记为T(S, t)。流水作业调度问题的最优值为
38
T(N,0)。

流水作业调度
解析：设是所给n个流水作业的一个最优调度，它所需的加工
时间为 a(1)+T’。其中T’是在机器M2的等待时间为b(1)时，安排
作业(2)，…，(n)所需的时间。
记S=N-{(1)}，则有T’=T(S, b(1))。
证明：事实上，由T的定义知T’T(S,b(1))。若T’>T(S,b(1))，
设’是作业集S在机器M2的等待时间为b(1)情况下的一个最优
调度。则(1)， ’(2)，…， ’(n)是N的一个调度，且该调度
所需的时间为a(1)+T(S,b(1))<a(1)+T’。这与是N的最优调度
矛盾。故T’T(S,b(1))。从而T’=T(S,b(1))。这就证明了流水作
业调度问题具有最优子结构的性质。
由流水作业调度问题的最优子结构性质可知，
T ( N ,0)  min {a i  T ( N  {i}, bi )}
1 i  n

T ( S , t )  min {ai  T ( S  {i}, bi  max{ t  ai ,0})}
iS

39

Johnson不等式
对递归式的深入分析表明，算法可进一步得到简化。
解析：设是作业集S在机器M2的等待时间为t时的任一最优调度。
若(1)=i, (2)=j。
则由动态规划递归式可得:

T(S,t)=ai+T(S-{i},bi+max{t-ai,0})=ai+aj+T(S-{i,j},tij)
tij  b j  max{ bi  max{ t  ai ,0}  a j ,0}
其中，  b  b  a  max{max{ t  a ,0}, a  b }
j
i
j
i
j
i
 b j  bi  a j  max{ t  ai , a j  bi ,0}
 b j  bi  a j  ai  max{ t , ai  a j  bi , ai }

如果作业i和j满足min{bi,aj}≥min{bj,ai}，则称作业i和j
满足Johnson不等式。
40

流水作业调度的Johnson法则
T(S,t)=ai+T(S-{i},bi+max{t-ai,0})=ai+aj+T(S-{i,j},tij)
其中， tij  b j  bi  a j  ai  max{ t , ai  a j  bi , ai }

交换作业i和作业j的加工顺序，得到作业集S的另一调度，它
所需的加工时间为 T’(S,t)=ai+aj+T(S-{i,j},tji)。
其中， t ji  b j  bi  a j  ai  max{ t , ai  a j  b j , a j }
解析：当作业i和j满足Johnson不等式时，有
max {  b ,  a }  max {  b ,  a }
i
j
j
i
a  a  max {  b ,  a }  a  a  max {  b ,  a }
i
j
i
j
i
j
j
i
max {a  a  b ,a }  max {a  a  b ,a }
i
j i i
i
j
j j
max {t,a  a  b ,a }  max {t,a  a  b ,a }
i
j i i
i
j
j j

由此可见，

t t ,
ij
ji

T(S, t)  T' (S, t)

41

流水作业调度的Johnson法则
当作业i和j满足Johnson不等式时，有
t  t , T(S,t)  T ' (S,t)
ij
ji
即，当作业i和作业j不满足Johnson不等式时，交
换它们的加工顺序后，作业i和作业j满足Johnson不等
式，不增加加工时间。
因此，对于流水作业调度问题，必存在最优调度 ，
使得作业(i)和(i+1)满足Johnson不等式。
进一步还可以证明，调度满足Johnson法则当且
仅当对任意i<j有：
min{ b (i ) , a ( j ) }  min{ b ( j ) , a (i ) }

由此可知，所有满足Johnson法则的调度均为最优调度。
42

算法描述
流水作业调度问题的Johnson算法
(1)令 N1  {i | ai  bi }, N 2  {i | ai  bi };
(2)将N1中作业依ai的非减序排序；将N2中作
业依bi的非增序排序；
(3)N1中作业接N2中作业构成满足Johnson法
则的最优调度。
算法复杂度分析：
算法的主要计算时间花在对作业集的排序。因此，在最坏情
况下算法所需的计算时间为O(nlogn)。所需的空间为O(n)。
43

例：

i

1

2

3

4

5

6

ai

5

1

8

5

3

4

bi

7

2

2

4

7

5

i

2

5

6

1

4

3

ai

1

3

4

5

5

8

bi

2

7

5

7

4

2

Johnson法则只是一个充
分条件，不是必要条件。
不符合这个法则的加工
顺序，也可能是最优顺
序。顺序(2，5，6，4，
1，3)不符合Johnson法
则，但它也是一个最优
顺序

• 序列A为(2，5，6，1)，序列B为(4，3)，构成
最优顺序为 (2，5，6，1，4，3)。
• 最优调度时间：28。
44

struct Jobtype {
int key;
int index;
bool job; };

sort(&d[0], &d[n], cmp);
算法第二步

bool cmp(Jobtype x, Jobtype y)
{ return x.key < y.key;}

int j = 0, k = n-1;
for (i = 0; i < n; i++) {
if(d[i].job)//ai<bi的作业的标志
c[j++] = d[i].index;//c存放作业序号
else
c[k--] = d[i].index; }

算法复杂度分析：
int
FlowShop(int n, int a[], int b[], int
M2等待时
c[])
{
算法的主要计算时间花在对作业集的排序。因此，在最坏情况
间
j = a[c[0]];
Jobtype
d[n+3];
k = j + b[c[0]];
下算法所需的计算时间为O(nlogn)。所需的空间为O(n)。
int i;
算法第一步
for ( i = 1; i < n; i++) {
j += a[c[i]];
for (i = 0; i < n; i++) {
k = j < k ? k + b[c[i]]: j+b[c[i]];
d[i].key = a[i] > b[i] ? b[i]:a[i];//key }
存放ai和bi中较小的
return k;
d[i].job = a[i] <= b[i];
}
d[i].index = i;
}
45

0-1背包问题
问题描述：给定n种物品和一背包。物品i的重量是wi，其价
值为vi，背包的容量为C。问应如何选择装入背包的物品，
使得装入背包中物品的总价值最大?
0-1背包问题是一个特殊的整数规划问题。
n

max  vi xi
i 1

X=(x1,x2,…,xnn)

n

  wi xi  C
 i 1
 xi {0,1},1  i  n

46

1、最优子结构性质
0-1背包问题具有最优子结构性质。
解析：
设(y1,y2,…,yn)是所给0-1背包问题的一个最优解，
则(y2,…,yn)是下面相应子问题的一个最优解：
n

max  vi yi
i 2

n
 wi yi  C－w1 y1
 i 2
 yi {0,1},2  i  n
47

设(y1,y2,…,yn)是所给0-1背包问题的一个最优解，
则(y2,…,yn) 是相应子问题的一个最优解。
证明：设(z2,…,zn)是上述子问题的一个最优解，
而(y2,…,yn)不是它的最优解。由此可知，

因此，
n

n

i 2

i 1

v1 y1   vi zi   vi yi ,

n

w1 y1   wi zi  C
i 2

这说明(y1,z2,…,zn)是所给0-1背包问题的一个更
优解，从而(y1,y2,…,yn)不是所给0-1背包问题的
最优解。此为矛盾。
故，(y2,…,yn) 是相应子问题的一个最优解。

48

2、递归关系
设所给0-1背包问题的子问题
n

max  v k x k
k i

 n
  wk xk  j
 k i
 xk  {0,1}, i  k  n

用动态规划分
阶段决策方法。
假定背包载重
范围为：0～C

的最优值为m(i，j)，即m(i，j)是前i个物体中，能
够装入载重量为j的背包中的物体的最大价值。
j=1,2,…,C。
49

3、动态规划函数
根据前i个物体中有些装入了背包，有些不
能装入背包，可得动态规划函数：
m(i,0)=m(0,j)=0

m(i,j)=

(1)式

物品i装入
max{m(i-1,j),m(i-1,j-wi)+vi} j≥wi
m(i-1,j)

j<wi

(2)式

物品i不装入

50

4、动态规划求解
划分阶段：
第一阶段：只装入1个物体，确定各种不同载重量背包下，能够获得最大值。
第二阶段：装入前2个物体，确定各种不同载重量背包下，能够获得最大值。
依次类推，直到第n个阶段，最后m(n,c)便是载重量为c的背包下，装入n个
物体时能够获得最大值。

确定装入：
从m(n,c)的值向前倒推：
m(n,c)> m(n-1,c)表明n物体装入背包，则问题化简为：
前n-1个物体被装入载重量为c-wn背包中。
m(n,c)<= m(n-1,c)表明n物体未装入背包，则问题化简为：
前n-1个物体被装入载重量为c背包中。
依次类推，直到第1个物体是否被装入背包为止。可得递推关系：
若： m(n,c)＝ m(n-1,c)
则 xi＝0
若： m(n,c) > m(n-1,c)
则 xi＝1,j=j-wi

51

例：设0-1背包的一个实例：n=5,c=10,w={2,2,6,5,4},v={6,3,5,4,6}

• 由动态函数递推m[ ][ ]如下：

i\j 0


若 m[i][j]=m[i-1][j] xi=0
若 m[i][j]>m[i-1][j] xi=1



故，最优解为(1,1,0,0,1)。
52

当wi为正整数时，用二维数组m[][]来存储m(i,j)的相应值。
void KnapSack(v[ ],w[ ],c, n,x[ ])
初始化m[ ][ ],x[ ];

{

for(int i=0;i<=n;i++) {

递推
过程

for(j=1;j<=c;j++) {
m[i][j]=m[i-1][j];
if((j>=w[i]&&(m[i-1][j-w[i]]+v[i]>m[i-1][j])

m[i][j]=m[i-1][j-w[i]]+v[i];
}
} 算法复杂度分析：

从m(i，j)的递归式容易看出，算法需要O(nc)计算时间。
当背包容量c很大时，算法需要的计算时间较多。例如，
当c>2n时，算法需要Ω(n2n)计算时间。
53

构造最优解：
void Traceback(m[ ][ ],w[ ], c, n, x[ ])
{
j=c;
for(int i=n; i>0; i--)
if(m[i][j]>m[i-1][j] {
x[i]=1;
j=j-w[i] ;
}
}
54

小结
通过以上论述，我们可以发现对于常见的最优化问
题，动态规划的算法思想是最好的解决方法了。它将问
题实例归纳为更小的、相似的子问题，并通过求解子问
题产生一个全局最优解。
动态规划允许这些子问题不独立，(亦即各子问题
可包含公共的子子问题)也允许其通过自身子问题的解
作出选择，该方法对每一个子问题只解一次，并将结果
保存起来，避免每次碰到时都要重复计算。因此，我们
需要学会利用这种思想来设计算法，并解决实际问题。

55

动态规划法和分治法
相同点：动态规划法与分治法法类似，它们都是将问题
实例归纳为更小的、相似的子问题，并通过求解子问题
产生一个全局最优解。
不同点：分治法中的各个子问题是独立的 (即不包含公
共的子子问题)，因此一旦递归地求出各子问题的解后，
便可自下而上地将子问题的解合并成问题的解。
但不足的是，如果当前选择可能要依赖子问题的解
时，分治法要做许多不必要的工作，重复地解公共的子
问题。

56

动态规划法
任何思想方法都有一定的局限性，超出了特定条件，它就失去了
作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满
足最优化原理和无后效性。
1.最优化原理（最优子结构性质）
最优化原理可这样阐述：一个最优化策略具有这样的性质，不论
过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决
策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优
的。一个问题满足最优化原理又称其具有最优子结构性质。
2.无后向性
将各阶段按照一定的次序排列好之后，对于某个给定的阶段状
态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过
当前的这个状态。换句话说，每个状态都是过去历史的一个完整总
结。这就是无后向性，又称为无后效性。
57

3.子问题的重叠性
动态规划将原来具有指数级复杂度的搜索算法改进成了具
有多项式时间的算法。其中的关键在于解决冗余，这是动态规
划算法的根本目的。
动态规划实质上是一种以空间换时间的技术，它在实现的
过程中，不得不存储产生过程中的各种状态，所以它的空间复
杂度要大于其它的算法。
动态规划的时间复杂度为O(n2)，搜索算法的时间复杂度为
O(n!) ，但从空间复杂度来看，动态规划算法为O(n2)，而搜索
算法为O(n)，搜索算法反而优于动态规划算法。
选择动态规划算法是因为动态规划算法在空间上可以承受，
而搜索算法在时间上却无法承受，所以我们舍空间而取时间。

58

