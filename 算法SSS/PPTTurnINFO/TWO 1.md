### 第2章 递归与分治策略

#### 2.1 递归的概念

**递归的定义**：递归是指直接或间接调用自身的算法。在递归算法中，函数通过调用自身来逐步解决问题。递归分为两类：
- **直接递归**：函数直接调用自己。
- **间接递归**：函数通过调用其他函数，最终再回到调用自身。

**递归的本质**：递归通过将原问题分解为相同类型的子问题来求解。子问题的解可以组合成原问题的解。

---

### 例1：阶乘函数的递归定义

阶乘函数是递归的一个经典例子。它通过递归公式将阶乘计算逐步分解为子问题。

递归定义如下：
\[
n! = \begin{cases}
1, & \text{当}n = 0 \\
n \times (n-1)!, & \text{当}n > 0
\end{cases}
\]

该递归包含两部分：
- **边界条件**：用于停止递归的条件（如n=0时返回1）。
- **递归方程**：用于将问题分解为更小的子问题。

```java
long factorial(int n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}
```

---

### 递归的两种主要方法

1. **基于归纳法的递归**：通过数学归纳法解决问题，从基础情况开始逐步构建问题的解。
   - 基础步：解决问题规模为1的情况。
   - 归纳步：将规模为n的问题转化为规模为n-1的问题，依次递归求解。
   
2. **基于分治法的递归**：将问题分解为若干个更小的子问题，递归解决子问题并合并结果。

---

### 例2：多项式求值的递归算法

多项式可以用递归的方式求解。多项式的递归形式为：

\[
P_n(x) = a_n x^n + a_{n-1} x^{n-1} + \dots + a_1 x + a_0
\]

通过递归定义为：

\[
P_n(x) = x P_{n-1}(x) + a_n
\]

```java
float horner_pol(float A[], float x, int n) {
    if (n == 0) return A[0];
    return horner_pol(A, x, n - 1) * x + A[n];
}
```
**时间复杂性**：该递归算法的时间复杂度为O(n)，因为每次递归调用只做一次乘法和一次加法，总共递归n次。

---

### 例3：Fibonacci 数列

Fibonacci 数列是另一个经典的递归问题。其定义如下：

\[
F(n) = \begin{cases}
1, & \text{当}n = 0 \\
1, & \text{当}n = 1 \\
F(n-1) + F(n-2), & \text{当}n > 1
\end{cases}
\]

```java
int fibonacci(int n) {
    if (n <= 1) return 1;
    return fibonacci(n-1) + fibonacci(n-2);
}
```
**时间复杂性**：Fibonacci递归的时间复杂度为O(2^n)，因为每次递归都会产生两次函数调用，递归树的大小呈指数增长。

---

### 例4：Ackerman 函数

Ackerman 函数是一个复杂的递归函数，无法用非递归的方式定义。它是双递归的例子，定义如下：

\[
A(n, m) = \begin{cases}
m + 1, & \text{当}n = 0 \\
A(n - 1, 1), & \text{当}n > 0 \text{且} m = 0 \\
A(n - 1, A(n, m - 1)), & \text{当}n > 0 \text{且} m > 0
\end{cases}
\]

---

### 例5：排列问题

递归还可以用于生成全排列。对于一个集合{r1, r2, ..., rn}，递归地生成其所有排列。

递归思想如下：
- 当n=1时，返回集合的唯一元素。
- 当n>1时，依次将每个元素作为首个元素，递归生成剩下元素的排列。

---

### 例6：Hanoi塔问题

Hanoi塔问题要求将n个圆盘从塔A移动到塔B，且移动过程中要遵守特定规则。其递归算法如下：

- 基础步：当n=1时，直接将圆盘从塔A移到塔B。
- 归纳步：将n-1个圆盘移到辅助塔C，将第n个圆盘移到塔B，然后将n-1个圆盘从塔C移到塔B。

```java
void hanoi(int n, char a, char b, char c) {
    if (n == 1) {
        printf("Move disk 1 from %c to %c\n", a, b);
    } else {
        hanoi(n-1, a, c, b);
        printf("Move disk %d from %c to %c\n", n, a, b);
        hanoi(n-1, c, b, a);
    }
}
```

**时间复杂性**：Hanoi塔问题的递归关系为h(n) = 2h(n-1) + 1，解得h(n) = O(2^n)。

---

### 递归的优缺点

**优点**：
- 递归算法结构清晰，易于理解。
- 递归算法便于证明正确性，尤其是通过数学归纳法。

**缺点**：
- 递归算法的运行效率较低，通常需要更多的时间和空间。
  
---

### 解决递归的优化方法

1. **用户定义栈**：使用栈模拟递归调用，虽然本质上仍是递归，但可以人工控制。
2. **递推实现**：将递归转化为迭代。
3. **尾递归优化**：尾递归可以在部分编译器中优化为迭代，从而减少栈空间的使用。

```java
long tailRecFactorial(long n, long acc) {
    if (n == 1) return acc;
    return tailRecFactorial(n - 1, acc * n);
}
```

---

### 分治策略

分治法通过将大问题分解为若干个子问题来解决，每个子问题的规模较小且相互独立。递归解决每个子问题，然后合并结果。分治法的典型应用包括快速排序和归并排序。

**基本步骤**：
1. 分解：将问题划分为若干个规模更小的子问题。
2. 解决：递归地解决子问题。
3. 合并：将子问题的解合并为原问题的解。

---

以上是递归和分治策略的核心概念和应用示例。请让我知道你对这些内容的理解情况，我可以根据你的反馈继续讲解或解答疑问。