第 7 章 TSAI
第 7

BRERA AR LX’
TD SZIR FP ADEA BE

靶 载 问题
布线 问题
0 一 1 Fiala

BAL

问题

旅行 售货员 问题

批 处 :

电路 板 排 列 问题

作业 调度

FD Sz BR FZ

单产 最 短路 径 问题
6.1 分 支 限 界

Es
加
tH
Ret
te
neal
=
i
is
ul
Cc
AR
Rel
14

Oo
s+
|
Cc
+
a

6.1 分 支 限 界 法 的 基本 思想

1. 分 支 限 界 法 与 牟

(2) 搜索 方式 的 不 同 :

AAA [a

oH 法 以 六 rN

宋 度 优 移 的 方式 搜索

解 空 间 树 ， 而 分 支 限 界 法 则 以 广度 优先 或 以 最 小 耗 克
优先 的 方式 搜索 解 空 间 树 。

6.1 分 支 限 界 法 的 基本 思想

2. ASR 7h 思想

分 支 限界 法 在 扩展 结 点 处 ， 先 生成 其 所 有 的 儿子 结
点 (分支 ) ， 然 后 再 从 当前 的 活 结 点 表 中 选择 下 一
个 扩展 结 点 。

为 加 速 搜索 进程 ， 在 每 个 活 结 点 处 ， 计 算 一 个 函数
值 (PRA) ， 并 根据 函 效 值 ， 从 当前 活 结 点 表 中 选
择 一 个 最 有 利 的 结 点 作为 扩展 结 氮 ， 使 搜索 朝 着 最
(HURRAY 7) 52 HEI

解 题 思路 : 首先 ， 形 成 问题 的 状态 空间 树 ， 然 后 每 次 选
FEA RES HR ATMA RT BR 《满足 约 束 条
fF, ARGO Meee SHIRA) 。

6.1 分 支 限 界 法 的 基本 思想

2. a} SBR FREE 思想

分 文 限 界 法 常 以 广度 优先 或 以 最 小 耗费 〈 最 大 效益 ) 优
先 的 方式 搜索 问题 的 解 空 间 树 。

分 六 限界 法 具体 此 又:

在 分 文 限界 法 中 ，。 每 一 个 活 结 氮 只 有 一 次 机 会 成 为 扩展
25 FA

aa 旦 成 为 扩展 结 氮 ， 融 一 次 性 产生 其 所 有 儿子 结

在 这 此 儿子 结 点 中 ， 导 到 不 可 行 解 或 导致 非 最 优 解 的 儿子
结 点 被 舍 莽 ， 其 余 儿 子 结 点 被 加 入 活 结 点 表 中 。
此 后 ， 从 活 结 点 表 中 取 下 一 结 点 成 为 当前 扩展 结 点 ， 并 重
SPA ay Rts.

IK Pit Bees SFR EN PT A SG ARR A SAY A

IF. 6

A
;

6.1 分 支 限 界 法 的 基本 思想

3. OLN AAD SR AR
(1) 队列 式 (FIFO) 分 支 限 界 法

按照 队列 先进 先 出 (FIFO) 原则 选取 下 一 个 节点 为
i FTI FA

C2) 优先 队列 式 分 支 限 界 法

按照 优 务 队 列 中 规定 的 优先 级 选取 优先 级 最 高 的 世 操
KA SB RET Fo

TFCBA SY PALE BYE ra CER ST Sek at KAY SUIE p
表示 。 结 点 的 优先 级 的 高 低 与 p 值 的 大 小 有 关 。 最 大 优先 队列 规
定 p 值 较 大 的 结 点 优先 级 较 高 。 在 算法 实现 时 通常 用 最 大 堆 来 实
现 最 大 优先 队列 。 类 似 地 同样 定义 最 小 堆 来 实现 最 小 优先 队列 。，
fil:

6.1 FSZIRF EAA BAB

0 一 1 背包 问题

n=3,w=[16,15,15],p=[45,25,25],c=30
十 队列 式 (FIFO) 分 支 限界 法

AlIB IC

BIC IE | ED 不 可 行

CIEIFIG

EF |G jm K(45) [1,0,0]

FIG mmm L(50) [0, 1， Mey, a.

M(25)

GS m= Ni25), 000) © o ; Oo ORG

活 结 点 表 FIFO 搜索 解 空间 树 的 方式 与 解 空间 树 广 麻 优 先 遍历 要

为 相似 ， 唯 一 个 同 为 : 不 搜索 以 不 可 行 结 总 为 根 的 子 树
6.1 FSZIRF EAA BAB

+ (FTI SPR «|: 0 一 1 背包 问题
A] B, C => Bds) C(0) m7 3.w=[16,15,15],P=[45,25,25],¢
B, C] D, E => E(45)
IE, C] J, K => K(45) [1, 0, 0]
C] F, G => F(25), G(0)
TF, G] L, M => L(50), [0, 1, 1] 0
MO 中

[G] N, O => N(25), O(O)
> 可 用 剪 枝 函 数 加 速 搜索
将 上 界 国 数 确定 的 每 个 结 点 的 上 界

© ®

\ 6 ON @
6 06, se

作为 优 移 级 ， 以 优先 级 的 非 增 序 抽
取 当 前 扩展 结 点 。

6.1 分 支 限 界 法 的 基本 思想

例 : 旅行 售货员 问题
示 售 货 员 要 到 奋 干 城市 去 推销 商品 ， 已 知 各 城市 之 间 的 路 程 。
他 要 选择 一 条 从 驻地 出 发 ， 经 过 每 个 城市 一 炎 ， 最 后 回 到 驻地
的 路 线 ， 使 总 路 程 最 短 。 例 n=4 ， 即 4 个 城市 ， 从 1 城市 出 发 。

6.1 分 支 限 界 法 的 基本 思想

队列 式 分 支 限界 法 :

[B] C, D,E

D, E] E.G

E, F,G]H,1
F,G,H,1]J,K

G,H, 1, J, K] L(59) [1,2,3,4]
H,

a

[
[
[E,
[E,

[G.
[H,

[I,
[J

[
优

L J, K] M(66)
J, K] N(25) [1, 3, 2, 4]
K]1-3-4(26)>N(25)
IPOS)
] QG9)
队列 式 分 支 限 界 法 :
] C, D, E => C(30), D(6), E(4)
C] J, K = 414), K(24)
C] H, 1 = H(11), 1(26)
C, I] N=> N(25) [1, 3, 2, 4
C, I] P= P(25) 4
T] Q => QG69)
C1 限界 掉

Ae FFESrPRERE

See

D,
J, K,
J, K,
K,
C,

[
[E,
[D.
[H,
[J
[K,
[

IQ [A & [|S I

,了
6.2 单产 最 短路 径 问 题

. 问题 摘 述

下 面 以 一 个 例子 来 说 明 单 源 最 短路 径 问题 : 在 下 图 所 给 的 有
向 图 G 中 ， 每 一 边 都 有 一 个 非 负 边 权 。 要 求 图 G 的 从 源 项 点 s
到 目标 顶点 t 之 间 的 最 短路 径 。

=

20),

13
g ON
1g’
5 r
aa oll
m

1

12
6.2 单产 最 短路 径 问 题

色 是 用 优先 队列 式 分 文 限界 法 解 有 向 图 G 的 单产 最

短路 径 问题 产生 的 解 间 枫 。 其 中 ， 每 一 个 结 点 旁边 的

数字 表示 该 结 点 所 对

应 的

当前 路 长 。

6.2 Rae Fate 1s (5) ee
2. 算法 思想

解 单产 最 短路 径 问 题 的 优先 队列 式 分 支 限界 法 用 一 极 小 堆 来 存储 活 结 辟
表 。 其 优先 级 是 结 点 所 对 应 的 当前 路 长 。

(1) 算法 从 图 G 的 源 顶 点 s 和 空 优 先 队 列 开始 。
(2) 结 点 s 被 扩展 后 ， 它 的 儿子 结 点 被 依次 加 入 扒 中 。

(3) 此 后 ， 算 法 从 堆 中 取出 具有 最 小 当前 路 长 的 结 点 作为 当前 扩展 结 点 ， 并 依次 检
但 与 当前 扩展 结 总 相 邻 的 所 有 项 避 。

(4) 如 果 从 当前 扩展 结 点 1 到 顶点 j 有 边 可 达 ， 且 从 源 s 出 发 ， 途 经 顶点 1 再 到 顶点 j
的 所 相应 的 路 径 的 长 度 小 于 当前 最 优 路 径 长 度 ， 则 将 该 顶点 j PARA RA BA
结 点 优 移 队 列 中 。

(5) 这 个 结 点 的 扩展 过 程 一 直 继 续 到 活 结 点 优先 队列 为 空 时 为 止 。

注 : 每 一 个 结 点 旁边 的
数字 表示 该 结 点 所 对 应
的 当前 路 长 4

6.2 单产 最 短路 径 问 题
3. EYAL ERR

- 在 算法 扩展 结 点 的 过 程 中 ， 一 旦 发 现 一 个 结 点 的 下 界 大 于 等 于 当
前 找到 的 最 短路 长 ， 则 算法 剪 去 以 该 结 氮 为 根 的 子 树 。

vq i3

ho .
Gil: 找到 一 条 路 径 ， 目 前 的 最 短路 径 是 8 ， 发 现 某 个 结 点 的 下 界 不
小 于 这 个 最 短路 径 ， 则 甬 校 :

6.2 单产 最 短路 径 问 题
3. BALERS

Q 在 算法 中 ， 利 用 结 点 间 的 控制 关系 进行 剪 枝 。 从 源 顶 点 s 出 发 ，2 条 (多
条 ) 不 同 路 径 到 达 图 G 的 同一 顶点 。 由 于 两 条 路 径 的 路 长 不 同 ， 因 此 可 以 将
Fe EPA I RLBSPS TPES R RESP ESZS2 (IRI SE SR EES RRA
径 74 i3

例 : 从 源 s 出 发 ， 经 过 边 b,g( 路 长 为 5) 和 经 过 c ，h (路 长 为 6) 的 两 条 路 径
都 到 达 G 的 同一 顶点 。 在 该 解 空 间 树 中 ， 这 两 条 路 径 相应 于 2 个 不 同 的 结 点 A
和 B ，A 结 点 相应 的 路 长 小 于 B 结 点 相应 的 路 长 (5<6 ) ， 因 此 ， 以 A 为 根 的
子 树 中 所 包含 的 从 s 到 t{t 的 路 长 小 于 以 B 结 点 为 根 的 子 树 中 所 包含 的 从 s Ft 的
路 长 ， 因 此 ， 可 以 将 B 剪 去 ， 称 A 结 点 控制 站 BAR.

6.2 单产 最 短路 径 问 题
4. 算法 摘 述

while (true)
{  // 搜索 问题 的 解 空间
for (int j=1; j<=n; j++)
if(a[enode.1][j] < Float MAX VALUE && enode.length+a[enode.1][j] < dist[j])
{V 顶点 i 到 顶点 j 可 达 ， 且 满足 控制 约束
dist[j|=enode.lengtht+a[enode.1][j];

Jira i #0 j 间 有 边 ， 且 此

we | 路 径 长 小 于 原先 从 原点
pli]=enode.i;//j 的 前 驱 结 点 是 1 “到 j 的 路 径 长

HeapNode node = new HeapNode(j,dist[j]);
heap.put(node);  // 加 入 活 结 点 优先 队列
}
if (heap.isEmpty() break;

else enode = (HeapNode) heap.removeMin();// 抽取 堆 中 下 一 个 结 点 成 为 当前 扩展 结 点
} 17
和 妆 载 问题

1 问题 摘 述

有 一 批 共 个 集装箱 要 装 上 2 盘 载 重量 分 别 为 C; aC, 的 轮船， 其 中

集
4 二 As ， 重量、 <c,t+
装 箱 i 的 重量 为 W ， 且 S040

装载 问题 要 求 确 定 是 否 有 一 个 合理 的 装载 方案 可 将 这 个 集装箱 装 上

这 2 艘 轮船 。 如 果 有 ， 找 出 一 种 装载 方案 。

容易 证 明 : 如 果 一 个 给 定 装 载 问题 有 解 ， 则 采用 下 面 的 梨 略 可 得 到

最 优 装 载 方案 。 一 [特殊 的 0-1 背包 问题
(1) 首先 将 第 一 般 轮 船 尽 可 能 装 满 ;

(2) 将 剩余 的 集装箱 装 上 第 二 艘 轮船 。

max y》 WiXi

i=1

s.t. 》 wxX<ci

i=1

xEl0,1,1<i<n ™
ew: 扩展 结 点 处 所 相应 的 载重 量 ; i: 当前 扩展 结 点 所 处 的

层 ; bestw : 当前 最 优 载 重

6.3 装载 问题

2. BASIC Sz BRINE

在 算法 的 while 循环 中 ， 首 先 , 检测 当前 扩展 结 点 的 左 儿 子 结 点 是 否
为 可 行 结 点 。 如 果 是 则 将 其 加 入 到 活 结 点 队列 (A queue 队列 存放 )
中 。 然 后 , 将 其 右 儿 子 结 点 加 入 到 活 结 点 队列 中 ( 右 儿 子 结 点 一 定 是
可 行 结 点 ) 《〈 结 点 加 入 队列 用 算法 enQueue ) 。 2 个 儿子 结 点 都 产
生 后 ， 当 前 扩展 结 总 被 舍弃 。

活 结 点 队列 中 的 队 首 元 素 被 取出 作为 当前 扩展 结 点 ， 队 列 中 每 一 层
结 氮 之 后 都 有 一 个 尾部 标记 -1 ， 故 在 取 队 首 元 素 时 ， 活 结 点 队列 一
定 不 空 。

结束 条 件 : 当 活 结 点 队列 中 取出 的 元 素 是 -1 时， 再 判断 当前 队列 是
否 为 空 。 如 果 队 列 非 空 ， 则 将 尾部 标记 -1 加 入 活 结 点 队列 ， 算 法 开
始 处 理 下 一 层 的 活 结 点 。

i= 1,ew = 0,bestw = 0,queue = null—>(a)
1

6.3 装载 问题
2. BAAS BRAGS

ew: 扩展 结 点 处 所 相应 的 载重 量 ; i: 当前 扩展 结 点 所 处 的 层 ; c : 轮船 1 的 载
=; wll): 集装箱 的 重量 ; bestw : 当前 最 优 载 重 。

queue : 活 结 点 队列 ， 队 列 中 元 素 的 值 表 示 活 结 点 所 相应 的 当前 载重 量 ;
enQueue 算法 : 将 活 结 点 加 入 到 活 结 点 队列 中 。

while (truey/ 搜索 子 集 空 间 树
{ /算法 enQueue HAA MMA BARS!
if(ew + w[i]<=c) enQueue(ew + wii], i); / 检查 左 儿子 结 点 x[i]=1
enQueue(ew, i); / 右 儿 子 结 点 总 是 可 行 的 ,x[i]=0
ew = ((Integer) queue.remove()).int Value(); / 取 下 一 扩展 结 点
if (ew ==-])
{ if (queue.isEmpty()) return bestw;
queue.put(new Integer(-1)); / 同 层 结 点 尾部 标志
ew = ((Integer) queueremove(O)intValue0: // 取 下 一 扩展 结 点
iH; / 进入 下 一 层
} 20
ae 24 in) §

6.3 妆 教 问题

2. BAFVZUS SRF

ew: 扩展 结 点 处 所 相应 的 载重 量 ; i: 当前 扩展 结 点 所 处 的 层 ; c : 轮船 1 的 载
=; wil: 集装箱 的 重量 ; bestw : Same.

queue : 活 结 点 队列 ， 队 列 中 元 素 的 值 表 示 活 结 点 所 相应 的 当前 载重 量 ;
enQueue 算法 : 将 活 结 点 加 入 到 活 结 点 队列 中 。

enQueue (int wt, int 1)

{RSG DOA EEE AGI

if(i—=n)
{ / 可行 叶 结 点 解 空 间 分 文 限界 搜索
if (wt > bestw) bestw=wt; aa maxLoading 时
间 复 杂 度 为
1 6 一 (2
else // 非 叶 子 结 点

queue.put(new Integer(wt)); /加 入 到 活 结 点 队列 中

算法 首先 检查 i 是 否 等 于 n ， 如 果 i = n ， 则 表示 当前 活 结 点 为 叶子 结 点 ，
叶子 结 点 不 会 被 扩展 ， 不 必 加 入 到 活 结 点 队列 中 ， 则 只 需 检查 该 叶子 结 点 表
示 的 可 行 解 是 否 优 于 当前 最 优 解 ， 如 果 是 ， 更 新 当前 最 优 解 。 当 i<n ， 当 前 21
活 结 总 是 内 部 结 吕 ， 则 应 加 入 到 活 结 点 队列 中 。
6.3 装载 问题
3. 算法 的 改进

氮 的 左 子 树 表示 将 此 集装箱 装 上 船 ， 右 子 树 表示 不 将 此 集装箱 装 上 船 。

iz bestw 是 当前 最 优 解 ; ew 是 当前 扩展 结 总 所 相应 的 重量 ; 了 是 剩余 集
装 箱 的 重量 。 则 当 ew+rmlbestw 时 ， 可 将 其 右 子 树 航 去 ， 因 为 此 时 各 要 船
装 最 多 集装箱 ， 就 应 该 把 此 箱 装 上 船 。

另外 ， 为 了 确保 右 子 树 成 功 剪 枝 ， 应 该 在 算法 每 一 次 进入 左 子 树 的 时 候 更
新 bestw 的 值 。

因为 ， 初 始 化 时 bestw=0, 直到 搜索 到 第 一 个 叶子 结 点 时 才 更 新 bestw ，
此 算法 在 搜索 到 第 一 个 叶子 之 前 ， 总 有 bestw = 0, 因此 总 有 ew 十
r>bestw 。 因 此 ， 为 了 使 得 对 右 子 树 的 测试 尽早 生效 ， 故 提前 更 新 bestw 。

22

6.3 seek) a
3. 算法 的 改进

算法 最 终 找到 的 最 优 值 是 所 求 问题 的 子 集 树 中 所 有 可 行 结 点 相应 的 重量 的 最 大 值 ，

而 结 点 所 相应 的 重量 仅 在 搜索 左 子 树 的 时 候 增加 ， 因 此 ， 可 以 在 算法 每 一 次 进入 左
子 树 的 时 候 更 新 bestw 。
A) LF BIR

/ 237) LAR / 2A) LFA

int wt=ew + w{i];// AJLFARNS= if (ew +1 > bestw && i<n)

| _ 提前 更 新 sabe a fs
if (wt <=) bestw / 可 能 含 最 优 解

{// ATH queue. put(new Integer(ew));
if (wt > bestw) bestw = wt; ew=((Integer)queue.remove())
/ MABE RI intValue(); / 取 下 一 扩展 结 点
if <n) 注 : 当 算法 要 将 一 个 活 结 点 插入 到 活 结 点 队列 中
queue.put(new Integer(wt)): AY, wt 的 值 是 不 会 超过 bestw ， 故 不 必 更 新

bestw ， 因 此 算法 可 以 直接 将 该 活 结 点 插入 到 活
} 结 点 队列 中 ， 不 必用 算法 enQueue 完成 插入 。

23
6.3 装载 问题

while (true)// 搜索 子 集 空 间 树

3. 算法 改进 前 后 比较 = ty 检查 左 儿 了 结 点

while (true)// 搜索 子 集 空间 树 int wt = ew + w[i]:/ 左 儿子 结 点 的 重量

{// 检查 左 儿子 结 点 if (wt <=c) // 可 行 结 点
if(ew+w[i]<=c) enQueue(ew + w{i], i); { if (wt > bestw) bestw = wt; / 更 新 bestw
enQueue(ew, i) // 右 儿 子 结 点 总 是 可 行 的 if(i<n)// 非 叶 子 ， 加 入 活 结 点 队列
ew = ((Integer) queue.remove()).intValue(); queue. put(new Integer(wt)); —}

/ 取 下 一 扩展 结 点 GEA) LFA

if (ew = -1) { if(ewt+r>bestw &&i<n)// 可 能 含 最 优 解

if (queue.isEmpty()) return bestw; 、
queue.put(new Integer(ew)); // 非 叶 子 加 入 活 结 点 队列

queue.put(new Integer(-1)); .
ew=((Integer)queue.remove()).intValue(); // 取 下 一 扩

/ 同 层 结 点 尾部 标志 展 结 点
ew = ((Integer) queue.remove()).intValue(); if (ew =-1) {/ 同 层 结 点 尾部 标志
/ 取 下 一 扩展 结 点 if (queue.isEmpty()) return bestw;// 活 结 点 队列 为 空
i++; // 进入 下 一 层 } queue.put(new Integer(-1)); W-1 揪 入 活 结 点 队列
}

24
ew=((Integer) queue.remove()).int Value();
jit 久久 = |
6.3 装载 问题
A. 构造 最 优 解
为 了 在 算法 结束 后 能 方便 地 构造 出 与 最 优 值 相应 的 最 优 解 ， 算 法

必须 存储 相应 子 集 树 中 从 活 结 点 到 根 结 点 的 路 径 。 为 此 目的 ， 可 在
每 个 结 点 处 设置 指向 其 父 结 点 的 指针 ， 并 设置 左 、 右 儿子 标志 。

与 此 相应 的 数据 类 型 QNode :

private static class QNode

{ Qnode parent: / 父 络 点
boolean leftChild; // 左 儿 子 标 志
int weight; / 结 点 所 相应 的 载重 量

}

将 活 结 点 加 入 到 活 结 点 队列 中 的 算法 enQueue 进行 相应 的 修改 ，
修改 后 的 算法 可 以 在 搜索 子 集 树 的 过 程 中 保存 当前 已 经 构造 出 的 子

集 树 中 的 路 径 ， 从 而 可 以 在 算法 结束 搜索 后 ， 从 子 集 树 中 与 最 优 值
相应 的 结 点 处 向 根 结 点 回溯 ， 构 造 出 相应 的 最 优 解 。

25
2 LS
6.3 委 载 问题

修改 后 的 enQueue 算法 :
enQueue (int wt , int 1, QNode parent, boolean leftChild )
{ 让 G==mn)V 可 行 叶 结 点

{ if (wt==bestw) { bestE=parent ) bestx[n] =(leftChild)? 1:05 }

return; }
else // 非 叶 子 结 点
{ QNode b= new QNode ( parent, leftChild, wt ) ; queue.put (b) ; }// 加 入 到 活 结 点 队列

找到 最 优 值 后 ， 可 以 根据 parent 回溯 到 根 节点 ， 找 到 最 优 解 ， bestx 中 存放
算法 找到 的 最 优 解 。
/ 构造 当前 最 优 解
for (ntJ]=n 一 1 ]>0)]--)
bestx[j] = (bestE.leftChild)?1:0; WbestE 为 当前 最 优 扩展 结 点
bestE = bestE.parent， V/ [Ij

}

20
6.3 seek) a
5. HFCBAFIZCUGA SR AG

解 委 载 问题 的 优先 队列 陈 分 文 限界 法 用 最 大 优先 队列 存储 活 结
Fate Weak x TEM FCP BAAR EMA MIRE BIZ A x
的 路 径 所 相应 的 载重 量 (ew) 再 加 上 剩余 集装箱 的 重量 (r)

之 和 。

FCAT RAN ARMA RM Baim. Wim
x 为 根 的 子 树 中 所 有 结 点 相应 的 路 径 的 载重 量 不 超过 它 的 优先
级 。 子 集 树 中 叶 结 点 所 相应 的 载重 量 与 其 优先 级 相同 。

注 : 在 优先 队列 式 分 支 限 界 法 中 ， 一 旦 有 一 个 叶 结 谈 成 为 当前
扩展 结 点 ， 则 可 以 断言 该 叶 结 点 所 相应 的 解 即 为 最 优 解 。 此 时
可 终止 算法 。

27
5. 优先

两 种 实现

(1) 在 结 氮 优 先 队 列 的 每 一 个 活 结 操 上

策略 :
Ro:

3 eines

BR INZUT SZ PRARE

保存 从 解 空 间

树 的 根 结 点 到 该 活 结 氮 的 路 径 。 算 法 确定 了 达到 最 优
值 的 叶 结 点 时 ， 在 该 叶 结 点 处 得 到 相应 问题 的 最 优

解 。

(2) 在 算法 |

空间 树 ， 在 确定 达到 最 优 值 时 ， 在 解 空 间 树

结 氮

始 向 根 匠

am

构造 出 相

鼻 索 过 程 中 保存 当前 已 经 构造 出 的 部 分 解

应 的 最 优 解 。

从 该 叶

28
65 0-1 背包 问题
。 算法 的 思想

首先 ， 要 对 输入 数据 进行 预 处 理 ， 将 各 物品 依 其 单位 重量 价值
从 大 到 小 进行 排列 。

在 下 面 描述 的 优先 队列 分 支 限 界 法 中 :

节点 的 优先 级 = 已 装 袋 的 物品 价值 + 剩 下 的 最 大 单位 重量 价值 的
物品 装 满 剩 余 容 量 的 价值 。

算法 首先 检查 当前 扩展 结 点 的 左 儿子 结 点 的 可 行 性 。 如 果 该 左 儿
子 结 点 是 可 行 结 京 ， 则 将 它 加 入 到 子 集 树 和 活 结 点 优先 队列 中 。

当前 扩展 结 点 的 右 儿 子 结 点 一 定 是 可 行 结 点 ， 仅 当 右 儿子 结 氮 满
足 上 界 约束 时 才 将 它 加 入 子 集 树 和 活 结 点 优先 队列 。 当 扩展 到 叶
帮 氮 时 为 问题 的 最 优 值 。

65 0-1 背包 问题
计算 结 点 所 相应 价值 的 上 界

p [] : 物品 的 价值 ; w [] : 物品 的 重量 ; b: LAME.

ER REX? ? —— bound 算法
while (i<=n && wli]<=cleft) //n RW, cleft 为 剩余 重量
{

cleft -= wi]; /iwii] Zen i VE

b += plil; //pli] 478 i ME

i++;

}

if(i<=n)b+=pfi]/wli]* cleft, // 装填 剩余 容量 装 满 背包
return b; lh A LAKBUB

30
at ae 日
65 0-1 育 包 问题
ICRA FUT SZ BR FRE A bbKnapsack 算法

p [] : 物品 的 价值 ; enode : 当前 扩展 结 点 ; cw: 当前 节点 所 相应 的 重量 ;
co: 当前 结 点 所 相应 的 价值 ; up: 价值 的 上 界 ; bestp : 当前 最 优 值 。

while CGI=n+l)

(// 非 叶 结 点 优先 队列 式 分 支
double wt = ew +w[]: 限界 搜索 过 程
if (wt <= c)

1/ 左 儿 子 结 点 为 可 行 结 点
if(cp+p[i]>bestp) —_ bestp = ep + pfi];
addLiveNode (up, cp + p[1], cw + w[i], 1+ 1, enode, true);
/将 一 新 的 活 结 点 插入 到 子 集 树 和 优先 队列 中
}
up = bound(i + 1):// 计算 价值 的 上 界
if(up >= bestp) /检查 右 儿 子 节 点 ， 满 足 上 界 约束
addLiveNode( up, cp, cw, i+ 1, enode , false);
/， 取 下 一 个 扩展 节点 (88)
6.6 最 大 团 问 题

问题 摘 述

给 定 无 向 图 G=(V ，E) 。 如 果 Us V ， 且 对 任意 u，v=<U 有 (u，
V) 一 E 》 则 称 U 是 G 的 完全 子 图 。 G 的 完全 子 图 U 是 G NSA
MS UF ERE G 的 更 大 的 完全 子 图 中 。 G 的 最 大 团 是 指 G 中 所
含 顶点 数 最 多 的 团 。

下 图 G 中 ， 子 集 {1 ，2} 是 G 的 大 小 为 2 的 完全 子 图 。 这 个 完全 子

图 不 是 团 ， 因 为 它 被 G 的 更 大 的 完全 子 图 {1 ，2 ，5} 包 含 。{1 ，
2，5} 是 G 的 最 大 团 。{1，4，5 和 人 {2，3，5} 也 是 G 的 最 大
团 。

例 : 无 向 图 G 32
6.6 最 大 财 癌 是
2. LFS 最 六 团 问题

用 变量 cliqueSize 表示 与 该 结 点 相应 的 团 的 顶点 数 ; level RNA
在 子 子 集 空间 树 中 所 处 的 层次 ; 用 cliqueSize +n-level+1 作为 顶点 数 上
界 upperSize 的 值 。

在 此 优先 队列 式 分 支 限 界 法 中 ， upperSize 实际 上 也 是 优先 队列 中 元
素 的 优先 级 。 算 法 总 是 从 活 结 点 优先 队列 中 抽取 具有 最 大 upperSize
值 的 元 素 作 为 下 一 个 扩展 元 素 。

ove 0 BN=0 US=5 cliquesize—cs
R ] uppersize—US
Besin —BN
a C8=08N=) US=4 |
7. rs fo 1 o11
【和 1 |
Sen aa —_. 101
C$? BN=2 = Pe=1 BHe? C51 四 网 元 忆 ge0 日 Msa
本 Usd = USn4 一 us=3 G=-|0 1001 ar) 2)
2) an) . / 人 110001
x fie? BN=? } “a sone 34 BN- C8=1 BNS2" Cosy ayaa I11110 人
Usa : - Us
Q Oe, “Oe. o 6 4
" Ms=2 Ole2 ; (5)
=
x r 4) ey 4
Lr AA A A 例 : 无 向 图 G
一 Fe i - i 上 4 ~
zyx xix x | x x} x mx x x x x
* §=3 BN= '
i & X 儿 % Xx X | x xii x KV Xx xx

33
CS=US 出 现 最 夫 团 BN=3
. 6.6 最 大 团 问 题
3. 算法 思想

算法 在 扩展 内 部 结 点 时 ， 首 先 考 察 其 左 儿子 结 点 。 在 左 儿 子 结 点 处 ， 将 顶点 i
加 入 到 当前 团 中 ， 并 检查 该 顶 点 与 当前 团 中 其 他 顶点 之 间 是 否 有 边 相 连 。 当
顶点 与 当前 团 中 所 有 项 总 之 间 都 有 边 相 连 ， 则 相应 的 左 儿 子 结 点 是 可 行 结
点 ， 将 它 加 入 到 子 集 树 中 并 插入 活 结 点 优先 队列 ， 否 则 就 不 是 可 行 结 点 。

接着 继续 考察 当前 扩展 结 点 的 右 儿 子 结 点 。 当 upperSize> Bestn 《当前 最

AGATA eX) 时 ， 右 子 树 中 可 能 含有 最 优 解 ， 此 时 将 右 儿 子 结 点 加 入 到 子
集 树 中 并 插入 到 活 结 点 优先 队列 中 。

ons OBN=01 cliquesize—Cs
up ze—US
; 国 Be — BN

C$=1 BN=1US6 ,

£
全 和 = 日 村 二 | US=4
伍 rN on li

— o1o60 1
Ce=2 Fs 一 it coe =7 7 Pog So =a
te BN: Ld BH=2 PCS =0 BN=2
uUs=5 Used 一 二 至 于 -天

34
CS=US 出 现 最 大 团 BN=3
6.6 最 大 团 问 题

算法 的 while 循环 的 终止 条 件 是 遇 到 子 集 树 中 的 一 个 叶 结 点
( 即 n+1 Rm ) 成 为 当前 扩展 结 点 。

对 于 子 集 树 中 的 叶 结 点 ， 有 upperSize = cliqueSize 。 此 时
活 结 点 优先 队列 中 剩余 结 点 的 upperSize 值 均 不 超过 当前 扩展

25 AY upperSize 值 ， 从 而 进一步 搜索 不 可 能 得 到 更 大 的 团 ，
此 时 算法 已 找到 一 个 最 优 解 。

OV ct CS) BN=0 LU S=6 cliquesize—cs

R) uppersize—US
ose ewer uses ; ve Bestn — BN
C in = iL ms. : al e5=08H=4) Used = 一
am HE] o J] Dll 1

(4) 1) |
- 2 z _ i ? = ! ° I ° :
€$=?BN=2 = Cbed BAe? C31 BN=2__-? F-C5=0 BN=2 §
US=56 USsd = US 一 Us=T> G=|0 1001
2) | a ) Me 2). ll oO 6 1
CHEN? WE : Sm 2BNEE Ts<4aN- 8 1 BNEZ csen-2i1 1 110

u

3) G 2) 国 une uss @ BJ uss “@)

_ 到
N=? :
x x PL) em a 4 4

CS=US 出 现 最 太 团 BN=3

35
6.7 旅行 售货员 问题

1. 问题 摘 述

某 售货员 要 到 知 干 城市 去 推销 商品 ， 已 知 各 城市 之 间 的 路 程 ( 或
旅费 ) 。 他 要 选 定 一 条 从 驻地 出 发 ， 经 过 每 个 城市 一 次 ， 最 后 回
到 驻地 的 路 线 ， 使 总 的 路 程 ( 或 总 旅费 ) 最 小 。

路 线 是 一 个 融 权 图 。 图 中 各 边 的 费用 ( 权 ) 为 正 数 。 图 的 一 条 有 周
游 路 线 是 包括 V 中 的 每 个 顶点 在 内 的 一 条 回路 。 周 游 路 线 的 费用
是 这 条 路 线 上 所 有 边 的 费用 之 和 。

旅行 售货员 问题 的 解 空 间 可 以 组 织 成 一 棵 树 ， 从 树 的 根 结 点 到 任
一 叶 结 点 的 路 径 定 义 了 图 的 一 条 周游 路 线 。 旅 行 售货员 问题 要 在
图 G PPh Fe bee) AY al Ea He

36
6.7 旅行 售货员 问题
2. 算法 摘 述

算法 开始 时 创建 一 个 最 小 堆 ， 用 于 表示 活 结 点 优先 队列 。 堆 中 每 个 结 损 的
子 树 费 用 的 下 界 icost 值 是 优先 队列 的 优先 级 。

“ 接着 算法 计算 出 图 中 每 个 顶点 的 最 小 费用 出 边 并 用 minout 记录 。

- 如 果 所 给 的 有 辐 图 中 某 个 顶点 没有 出 边 ， 则 该 图 不 可 能 有 回路 ， 算 法 即 告
结束 。

” 如 果 每 个 顶点 都 有 出 边 ， 则 根据 计算 出 的 minout 作 算法 初始 化 。

算法 中 ， 最 小 堆 数据 类 型 为 HeapNode ，s 是 整数 ， 表 示 结 点 在 排列 树
中 的 层次 ， 从 排列 树 的 根 结 点 到 该 结 点 的 路 径 为 x[0:s] ， 进 一 步 搜索 的 顶
RESEA x[st1:in-1], cc 为 当前 费用 ，lcost 为 子 树 费 用 的 下 界 ， 即 当
前 结 点 子 树 中 任意 叶子 结 点 中 的 最 小 耗费 ， rcost 为 x[s:n-1] 中 顶点 最
小 出 边 费用 之 和 ， beste 为 当前 最 小 耗费 。

初始 化 : s=0 ，x[0]=1,cc=0,rcost= > minout[i]

= 46 = 一 日
6.7 旅行 售货员 问题
算法 的 while 循环 体 完 成 对 排列 树 内 部 结 点 的 扩展 。 对 于 当前 扩
展 结 点 ， 算 法 分 2 种 情况 进行 处 理 :

首先 考虑 s=n-2 的 情形 ， 此 时 当前 扩展 结 点 是 排列 树 中 某 个
叶 结 点 的 父 结 点 。 如 果 该 叶 结 总 相应 一 条 可 行 回路 且 费 用 小
于 当前 最 小 费用 ， 则 将 该 叶 结 总 插入 到 优先 队列 中 ， 否 则 人
去 该 叶 结 点 。

当 s<n-2 时 ， 算 法 依次 产生 当前 扩展 结 点 的 所 有 儿子 结 点 。

由 于 当前 扩展 结 点 所 相应 的 路 径 是 x[0:s] ， 其 可 行 儿 子 结 点
是 从 剩余 顶点 x[s+1:n-1] 中 选取 的 顶点 xil ， 且 (x[s] ， x[i])
是 所 给 有 向 图 G 中 的 一 条 边 。 对 于 当前 扩展 结 点 的 每 一 个 可
行 儿子 结 点 ， 计 算出 其 前 缀 (x[0:s] ， x[i) 的 费用 cc 和 相应 的
FF Icost. 4 Icost<bestc 时 ， 将 这 个 可 行 儿子 结 点 插入 到
活络 点 优先 队列 中 。

优先 级 = 结 点 当前 费用 优先 级 = 结 点 的 子 树 费 用 的 下 界 ;。
6.7 旅行 售货员 问题

算法 中 while 循环 的 终止 条 件 是 排列 树 的 一 个 叶 结 总 成 为 当前
扩展 结 点 。

3) 当 s=n-1 时 ， 已 找到 的 回路 前 缀 是 x[0:n-1] ， 它 已 包含 图 G
的 所 有 n 个 顶点 。 因 此 ， 当 s=n-1 时 ， 相 应 的 扩展 结 点 表示 一 个
叶 结 点 。 此 时 该 叶 结 点 所 相应 的 回路 的 费用 等 于 cc 和 Icost 的
值 。 剩 余 的 活 结 点 的 Ilcost 值 不 小 于 已 找到 的 回路 的 费用 。 它 们
都 不 可 能 导致 费用 更 小 的 回路 。 因 此 已 找到 的 叶 结 点 所 相应 的 回
路 是 一 个 最 小 费用 旅行 售货员 回路 ， 算 法 可 以 结束 。

算法 结束 时 返回 找到 的 最 小 费用 ， 相 应 的 最 优 解 由 数组 v 给
出 。 © 优先 队列 式 分 支 限界 法 :

[B] C, D, E => C(50), D(25), E(25)
[D, E, C] H, I => H(25), 1(66)

[E, H, C,I] J, K => J(25), K(59)

[EL J,C,K, I] N => N(25)

[J, N, C, K, I] P= P(25 )

[N, PC, K, 1 =>N(25) [1,3,2,4],

cc=Icost

es 59
6.9 批 处 理 作 业 问 题
.问题 的 摘 述

给 定 n 个 作业 的 集合 J={J1+,Jz ,Jr 。 每 一 个 作业 Ji 都 有 2 项 任
务 要 分 别 在 2 台 机 器 上 完成 。 每 一 个 作业 必须 先 由 机 器 1 处 理 ， 然
后 再 由 机 器 2 处 理 。 作 业 上 需要 机 器 j 的 处 理 时 间 为 苹 ，i=1,2，
5n 》 12 。 对 于 一 个 确定 的 作业 调度 ， 设 是 Fi 是 作业 i 在 机 器
j 上 完成 处 理 的 时 间 。 则 所 有 作业 在 机 器 2 上 完成 处 理 的 附 站 用 cP,

称 为 该 作业 调度 的 完成 时 间 和 。 批 处 理 作业 调度 问题 要 求 对 于 给 定
的 n 个 作业 ， 制 定 最 佳作 业 调 度 万 案 ， 使 其 完成 时 间 和 达到 最 小 。

—

2

41

6.9 批 处 理 作 业 问 题
2. 限界 函数

分 析 : 由 于 要 从 n 个 作业 的 所 有 排序 中 找 出 具有 最 小 完成 时 间 和 的 作业
调度 ， 因 此 批 处 理 作 业 问 题 的 解 空 间 树 是 一 棵 排列 树 。

在 作业 调度 问题 相应 的 排列 树 中 ， 每 个 结 点 E 都 对 应 于 一 个 已 排列 的 作
West [(1,2,3----n} 以 该 结 点 E 为 根 的 子 树 中 所 含 叶 子 结 点 的
完成 时 i 以 表示 大

完成 时 间 和 可 以 表 》 B+ 》 E,

i€M i¢ M
设 | M | =r，L 是 以 E 结 点 为 根 的 子 树 中 的 一 个 叶子 结 点 ， 相 应 的 作
WEA {pk ，k 三 12，……… ，nj} ， 其 中 p, 是 第 k 个 安排 的 作业 ，

如 果 从 结 点 E 开始 到 叶子 结 点 上 L 的 路 上 ， 每 个 作业 p, 在 机 器 1 上 完成
处 理 后 都 能 立即 在 机 器 2 上 开始 处 理 ， 即 从 p, , 开始 ， 机 器 1 BSS
闲 时 间 ， mat Ee EAR, Hn K+1jb ttoy ES;

k=r+1 » F,,
各 不 能 做 到 这 一 点 ， 则 S, 会 增加 ， 从 而 有 ie >=, 。
6.9 批 处 理 作 业 问 题

2. 限界 国 数

类 似 的 ， 如 果 从 结 点 E 开始 到 上 的 路 上 ， 从 作业 从 p, + ;开始 ， 机 器
2 没有 空 内 时 间 ， 则 有

之 F,,2 > > | [max ( F,, F,,,+min(t,;])+(n-k+1)t,,.J=S,
rat.’ “SEITE E 处 相应 子 树 中 叶 结 点 完成 时 间 和 的 下 界 是 :
f= >》 F,,+max S,,S,|
i€M
注意 : 如 果 选 择 Pr, 1E tix HE k>=f+1 时 依 非 减 序 排 列 ， S 则 取
得 极 小 值 。 同 理 如 果 选 择 Px 使 tm 依 非 减 序 排 列 ， 则 S, 取得 极 小

ms f>>, F,,+max|S,, S,|

LGA

这 可 以 作为 优先 队列 式 分 支 限界 法 中 的 限界 函数 。 .
6.9 批 处 理 作 业 问 题
3. BATRA

算法 用 最 小 扒 来 表示 活动 结 点 优先 队列 ， 最 小 堆 中 元 素 类 型 是
HeapNode ， 每 个 HeapNode 类 型 的 结 点 包含 域 x ， 表 示 结 点 所 相
应 的 调度 。 s 表示 该 活 结 点 已 安排 的 作业 是 x[1:s] 。 1 表示 当前 已
安排 的 作业 在 机 器 1 上 的 最 后 完成 时 间 ; f2 表示 当前 已 安排 作业 在
机 器 2 上 的 最 后 完成 时 间 ; sf2 表示 当前 已 安排 的 作业 在 机 器 2 上
的 完成 时 间 和 ; bb 表示 当前 完成 时 间 和 的 下 界 。

算法 的 while 循环 完成 对 排列 树 内 部 结 点 的 有 序 扩展 。 在 while
循环 体内 算法 依次 从 活 结 点 优先 队列 中 取出 具有 最 小 bb 值 〈 完 成
时 间 和 下 界 ) 的 结 点 作为 当前 扩展 结 点 ， 并 加 以 扩展 。

44
6.9 批 处 理 作 业 问 题
3. BATRA

算法 将 当前 扩展 结 点 enode 分 两 种 情形 处 理 。

首先 考虑 enode.s=n 的 情形 ， 当 前 扩展 结 点 enode 是 排列 树 中
的 叶 结 点 。 enode.sf2 是 相应 于 该 叶 结 点 的 完成 时 间 和 。 当
enode.sf2 < bestc 时 ， 更 新 当前 最 优 值 bestc 和 相应 的 当前 最 优 解
bestx 。

当 enode.s<n 时 ， 算 法 依次 产生 当前 扩展 结 京 enode 的 所 有 儿
子 结 点 。 对 于 当前 扩展 结 点 的 每 一 个 儿子 结 点 node ， 计 算出 其 相
应 的 完成 时 间 和 的 下 界 bb 。 当 bb < bestc 时 ， 将 该 儿子 结 点 插入
到 活 结 点 优先 队列 中 。 而 当 bb = bestc 时 ， 可 将 结 点 node 舍 去 。

45
6.9 批 处 理 作 业 问 题
3. 算法 摘 述

do “4 enode.sf2<bestc 时 ，
{ 更 新 当前 最 优 值 beste 和 相
if (enode.s ==n ) {// 叶 结 点 应 的 最 优 解 bestx
if (enode.sf2 < bestc) {
bestc = enode.sf2;
for (int 1= 0; 1 <n; 1++)

bestx[i] = enode.x[i];

46
6.9 批 处 理 作 业 问 题

3. BATRA

else // 产生 当前 扩展 结 点 的 儿子 结 点

for (int 1 = enode.s; 1 <n; 1++) { 当 bb<bestc 时 ，
My Math.swap(enode.x, enode.s,1); 1) LFA RAB
活 结 点 优先 队列 中

int [] f= new int [3];
int bb=bound(enode,f):// 完成 时 间 和 的 下 界
if (bb < beste ) {/ 子 树 可 能 含有 最 优 解
HeapNode node=new HeapNode(enode,f,bb,n);// 结 点 插入 最 小 堆
heap.put(node); }
My Math.swap(enode.x, enode.s,1);
}V 完成 结 点 扩展
enode=(HeapNode)heap.removeMin(); // 取 下 一 个 扩展 结 点

】 while(enode!=null&&enode.s<=n)

47
小 结

O 分 支 限界 法 常 以 广度 优先 或 以 最 小 耗费 (RARE)
优先 的 方式 搜索 问题 的 解 空 间 树 。 对 已 处 理 的 各 结 谈

根据 限界 为 效 估算 目标 到 数 的 可 能 取 值 ， 从 上
目标 邓 数 取得 极 大 《小 ) 值 的 结 点 优先 进行 广

选取 是
Est

搜索 于 不 断 调整 搜 索 方向 ， 尽 快 找到 解 ， 裁 剪 那些 不
能 得 到 最 优 解 的 子 树 以 提高 搜索 效率 。

口 特点 : 限界 函数 党 基 了

问题 的 目标 钞 数 ， 适 用 3

最 优化 问题 。

求解

48
小 结

搜索 策略 : 在 扩展 结 点 处 ， 先 生成 其 所 有 的 儿子 结 点
(分 文 ) ， 然 后 再 从 当前 的 活 结 点 表 中 选择 下 一 个 扩
FEZE Fo

ANY Axia RM 4am, LAMM AR Aye
程 ， 在 每 一 活 结 点 处 ， 计 算 一 个 函数 值 〈 优 先 值 ) ，
并 根据 这 些 已 计算 出 的 男 效 值 ， 从 当前 活 结 点 表 中 选
择 一 个 最 有 利 的 结 点 作为 扩展 结 氮 ， 使 搜索 绷 着 解 空
间 树 上 有 最 优 解 的 分 文 推 进 ， 以 便 尽 快 地 找 出 一 个 最
优 解 。

49
小 结
OC 求解 步骤 :
> 定义 解 空间 ;
> 确定 解 空 间 的 树 结 构 5
> 按 BFS (VF Bit) 方式 搜索 :

确定 一 个 合理 的 限界 函数 ， 并 根据 限界 函数 确定 目标 函数 的 界 .
按 广度 优先 策略 遍历 问题 的 解 空间 树 :

A. 在 当前 E 结 点 上 ， 依 次 搜索 该 结 点 E 的 所 有 儿子 结 点 ， 分 别 估算
这 些 孩子 结 点 的 目标 函数 的 可 能 取 值 。

B. 如 果 某 儿子 结 点 的 目标 函数 可 能 取得 的 值 超出 目标 卫 数 的 界 ， 则
BREF; 否则 ， 将 其 加 入 活 结 点 表 中 。

C. 再 依次 从 活 表 中 选取 使 目标 函数 的 值 取得 极 值 的 结 点 成 为 当前 E
@ 重复 上 述 过 程 ， 直 到 找到 最 优 解 。

50
