### 第5章 回溯算法

#### 1. 回溯算法的基本概念

回溯算法是一种系统地搜索解空间的算法，尤其适用于组合问题和排列问题。在这些问题中，解的数量可能非常大，直接的暴力枚举方法效率低下。回溯算法通过采用**深度优先搜索**，逐步构造解，并在搜索过程中通过**剪枝**避免不必要的计算，从而减少搜索空间。

#### 2. 回溯法的核心策略

1. **解空间的定义**：解空间是问题中所有可能解的集合。回溯算法通过系统地搜索解空间树来找到问题的解。
2. **解向量**：解向量是表示问题解的方式，通常用一个n元组表示，例如对于n个物品的0-1背包问题，解向量可以是一个二进制向量，表示每个物品是否被放入背包。
3. **显式约束与隐式约束**：
   - **显式约束**：直接限制解向量中每个元素的取值范围，例如0-1背包问题中，物品的选择只能是0或1。
   - **隐式约束**：对解的整体性质的限制，例如不能超过背包容量。

#### 3. 回溯法的搜索策略

- **深度优先搜索 (DFS)**：回溯算法在解空间树中按照深度优先的顺序进行搜索，每次递归扩展一个结点，并检查是否满足问题的约束条件。
- **剪枝策略**：如果发现当前解不满足约束条件，则直接终止对该子树的进一步搜索，这一过程称为剪枝。

#### 4. 经典回溯问题

##### 4.1 0-1 背包问题

**问题描述**：给定n种物品，每种物品有重量和价值，背包有一个最大容量，目标是在不超过背包容量的情况下，选择物品使得背包中的总价值最大。

**解空间树**：可以用二叉树表示，树的每一层表示对一个物品的选择，左分支表示不选择该物品，右分支表示选择该物品。

```java
private static void backtrack(int i, int[] w, int[] v, int c, int cw, int cp, int bestp, int[] x) {
    if (i > n) {
        if (cp > bestp) bestp = cp;
        return;
    }
    // 左分支：选择当前物品
    if (cw + w[i] <= c) {
        x[i] = 1;
        cw += w[i];
        cp += v[i];
        backtrack(i + 1, w, v, c, cw, cp, bestp, x);
        cw -= w[i];
        cp -= v[i];
    }
    // 右分支：不选择当前物品
    x[i] = 0;
    backtrack(i + 1, w, v, c, cw, cp, bestp, x);
}
```

**剪枝条件**：通过上界函数估算当前子树可能得到的最大价值，如果该上界值小于当前已知的最优解，就可以剪枝。

##### 4.2 n皇后问题

**问题描述**：在nxn的国际象棋棋盘上放置n个皇后，使得任意两个皇后不在同一行、同一列或同一对角线上。

**解向量**：n元组(x1, x2, ..., xn)表示每个皇后所在的列。

```java
private static boolean place(int k, int[] x) {
    for (int j = 1; j < k; j++) {
        if (Math.abs(k - j) == Math.abs(x[j] - x[k]) || x[j] == x[k])
            return false;
    }
    return true;
}

private static void backtrack(int t, int n, int[] x) {
    if (t > n) {
        // 找到一个解，处理解
        return;
    }
    for (int i = 1; i <= n; i++) {
        x[t] = i;
        if (place(t, x)) backtrack(t + 1, n, x);
    }
}
```

**剪枝条件**：只要有两个皇后在同一列或同一对角线上，就可以直接剪枝，避免进一步扩展。

##### 4.3 旅行商问题 (TSP)

**问题描述**：给定n个城市，旅行商需要从某个城市出发，经过每个城市一次并最终回到出发城市，目标是找到总路程最短的路径。

**解空间树**：可以用排列树表示，树的每一层表示对下一个城市的选择。

```java
private static void tspBacktrack(int i, int n, int[][] dist, int[] x, int bestDist, int curDist) {
    if (i == n) {
        curDist += dist[x[n - 1]][x[0]]; // 回到起点
        if (curDist < bestDist) bestDist = curDist;
        return;
    }
    for (int j = i; j < n; j++) {
        swap(x, i, j);
        curDist += dist[x[i - 1]][x[i]];
        if (curDist < bestDist) tspBacktrack(i + 1, n, dist, x, bestDist, curDist);
        curDist -= dist[x[i - 1]][x[i]];
        swap(x, i, j);
    }
}
```

#### 5. 回溯法的优缺点

- **优点**：
  - 系统性强，能够保证找到问题的解。
  - 通过剪枝技术，可以显著减少搜索空间，提高效率。
  
- **缺点**：
  - 在最坏情况下，仍可能需要遍历所有解空间，时间复杂度较高。

#### 6. 总结

回溯算法是一种通过构建解空间树、深度优先搜索、并结合剪枝技术来减少无效搜索的算法。它能够有效解决许多复杂的组合优化问题，但对于某些问题，可能还需要结合动态规划或启发式算法来进一步优化。