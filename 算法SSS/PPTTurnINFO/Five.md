第 S$ 章 回 漳 法
° 8 fa

OBR
+ 理解 回 湖 法 的 深度 优先 策略

可 调 法 解
-于 集 树 算 法 框
— 排列 树 算 法 框
。 通 过 范例 学 习 听

的 算法 框架

dy
IR

溯 法 的 设计 策略

- 装载 问题 ， 符 号 三 角形 ，n 后 问题 ，0 一 1 背

包 问 题 ，

色 着 色 问 题
* =| *
问题 的 解 空 间
。 应 用 回溯 法 解 问题 时 ， 首 先 应 明确 定义 问题 的 解 空 间 。 问
题 的 解 空 间 应 至 少 包含 问题 的 一 个 最 优 解 。
。 问题 的 解 向 量 : 回溯 法 希望 一 个 问题 的 解 能 够 表示 成 一 个
n 元 式 (x,, 关 2，.….， x.) 的 形式 。
。 显 约束 : 对 分 量 x; 的 取 值 限定 。

。 隐 约束 ; 为 满足 问题 的 解 而 对 不 同 分 量 之 间 施 加 的 约束 。
。 解 空间 ， 对 于 问题 的 一 个 实例 ， 解 向 量 满足 显 式 约束 条 件
的 所 有 多 元 组 ， 构 成 了 该 实例 的 一 个 解 空间 。

例 : n=3 时 的 0-1 育 包 问 题 用 完全 二 又 树 表 示 的 解 空 间 3
回溯 法

是 满足 某 些 约束 条 件 的 最 佳 解 时 ， 人 往往 要 使 用 下

梧 淹 法 的 基本 做 法 是 搜索 ， 或 是 一 种 组 织 得 井 井

一 些 组 合 数 相当 大 的 问题 。
” 回溯 法 在 问题 的 解 空 间 树 中 ， 按 深度 优先 策略 ，

”有 许多 问题 ， 当 甫 要 找 出 所 的 解 集 或 者 要 求 回合 作 么 解

Hl BAPE
有 条 的 ，

能 避免 不 必要 搜索 的 穷 举 式 搜索 法 。 这 种 方法 适用 于 解

WAR Bi

点 出 友 搜 索 解 空间 树 。 算 法 搜索 至 解 空间 树 的 任意 一 结

点 时 ， 爷 判断 该 结 点 是 否 包 合 问 题 的 解 。 如 果 肯
含 ， 则 跳 过 对 该 结 氮 为 根 的 子 树 的 搜索 ， 逐 层 问

re
其 祖先

结 所 回溯; 否则， 进入 该 子 树 ， 继 续 按 深度 优先 案 略 搜

索 °

图 : 深度 优先 搜索
状态 空间 相关 概念

问题 状态 : 树 中 的 每 一 个 结 点 确定 所 求解 问题 的 一 个 问
题 状 态 。

状态 空间 : 由 根 结 点 到 其 他 结 点 的 所 有 路 径 确定 了 这 个
问题 的 状态 空间 。

扩展 结 点 :一 个 正在 产生 儿子 的 结 氮 称 为 扩展 结局。

活 结 点 :一 个 目 身 己 生 成 但 其 儿子 还 没有 全 部 生成 的 节
点 称 做 活 结 点 。

死结 点 :一 个 所 有 儿子 已 经 产生 的 结 点 称 做 死结 点 。

例 : n=3 时 的 0-1 背 包 问 题 用 完全 二 又 树 表 示 的 状态 空间 树
回溯 法

。 深度 优先 的 问题 状态 生成 法 : WRT PS AG SF,

一 旦 产生 了 它 的 一 个 儿子 S$， 束 把 $ 当 做 新 的 扩展 绪 点 。

在 完成 对 了 于 树 $S《〈 以 $ 为 根 的 子 树 ) 的 人 务 义 搜索 之 后 ，

将 F 重 新 变 成 扩展 结 点 ， 继 续 生 成 F 的 下 一 个 儿子 《如

RRAFTE) 。

。 宽度 优先 的 问题 状态 生成 法 : 在 一 个 扩展 结 点 变 成 死

结 点 之 前 ， 它 一 直 是 扩展 结 点 。

© 回溯 法 : 为 了 避免 生成 那些 不 可 能 产生 最 佳 解 的 间 题
状态 ， 要 不 断 地 利用 限界 函数 (bounding function) 来

处 死 那些 实际 上 不 可 能 产生 所 需 解 的 活 结 点 ， 以 减少

问题 的 计算 量 。 具 有 限界 函数 的 深度 优先 问题 状态 生
成 法 称 为 回溯 法 。

Cagarnideetb tend

“在 解 空 间 中 ， 问 题 的 求解 就 是 搜索
搜索 的 基本 问题 是 :
(1) 搜索 过 程 是 合 一 定 能 找到 一 个 解 ;

(2) 搜索 过 程 是 否 能 终止 运行 或 是 会 陷入
— “SFE EA

(3) 当 搜 索 过 程 找到 解 时 ， 找 到 的 是 售 是
最 佳 解 ;

(4) 搜索 过 程 的 时 间 与 空间 复杂 性 如 何 。

回溯 法 的 基本 思想

可 漳 法 的 基本 步骤 :

(1) 针 对 所 给 问题 ， 定 义 问 题 的 解 空 间 ;

(2) 确 定 易于 搜索 的 解 衬 间 结 构 ;

(3) 以 深度 优先 方式 搜索 解 空 间 ， 并 在 搜索 过 程 中 用 剪 梳
函数 避免 无 效 搜索 。

例 : n=3, C=30, w={16, 15, 15},

v={45, 25, 25} 一

扩展 A， 先 到 达 B 结 点

Cr=Cr-wl=14, V=V+v1=45

此 时 A、B 为 活络 点 ，B 成 为 当前 扩展 结 点

扩展 B， 先 到 达 D

— Cr<w2，D 导 致 一 个 不 可 行 解 ， 回 溯 到 B

再 扩展 B 到 达 E

ae 此 时 A、B、E 是 活络 点 ，E 成 为 新 的 扩展 结

扩展 E， 先 到 达 J

- Cr<w3，J 导 致 一 个 不 可 行 解 ， 回 渊 到 E

再 次 扩展 E 到 达 K

— ”由 于 K 是 叶 结 点 ， 即 得 到 一 个 可 行 解 xz=(1.0.0)
，V=45

-天 不 可 扩展 ， 成 为 死结 点 ， 返 回 到 E

下 没有 可 扩展 结 点 ， 成 为 死结 点 ， 返 回 到 B

B 没 有 可 扩展 结 点 ， 成 为 死结 点 ， 返 回 到 A

A 再 次 成 为 扩展 结 点 ， 扩 展 A 到 达 C

Cr=30，V=0， 活 结 点 为 A、C，C 为 当前 扩展 结 点

扩展 C， 先 到 达 F

Cr=Cr-w2=15，V=V+v2=25， 此 时 活 结 点 为 A、C、EF

， 了 成 为 当前 扩展 结 点

扩展 FE， 先 到 达 L

— Cr=Cr-w3=0, V=V+v3=50

— Lieittaas, H50>45, SI —PS aT He
x=(0,1,1), V=50 .

工 不 可 扩展 ， 成 为 死结 点 ， 返 回 到 F es

0-1 背 包 问 题

再 扩展 F 到 达 M

M 是 叶 结 点 ， 且 25$<50， 不 是 最 优 解 ，M 不 可 扩展 ， 成 为
死结 点 ， 返 回 到 F

FE 没 有 可 扩展 结 点 ， 成 为 死结 点 ， 返 回 到 C

再 扩展 C 到 达 G

Cr=30，V=0， 活 结 点 为 A、C、G，G 为 当前 扩展 结 点

扩展 G， 先 到 达 N，N 是 叶 结 点 ， 且 2$<50， 不 是 最 优 解 ，
又 N 不 可 扩展 ， 返 回 到 G

再 扩展 G 到 达 O，O 是 叶 结 点 ， 且 0<$0， 不 是 最 优 解 ， 又
O 不 可 扩展 ， 返 回 到 G

G 没 有 可 扩展 结 点 ， 成 为 死结 点 ， 返 回 到 C
C 没 有 可 扩展 结 点 ， 成 为 死结 点 ， 返 回 到 A

A 没 有 可 扩展 结 点 ， 成 为 死结 点 ， 算 法 结束 ， 最 优 解
X=(0,1,1)， 最 优 值 V=50。

(a) C=C=30, V=0

> 问题;

王城
城市
一 条

城市 一
路 线 ，
。 该 问
有 @-
。 了 最 优

256

旅行 售货员 问题

述 : RG BIA
市 去 推销 商品 ， 一 直 各

之 间 的 路 程 ， 他 要 选 定
从 驻地 出 发 ， 经 过 每 个
迄 ， 最 后 回 到 住地 的

使 总 的 路 程 最短 。
题 是 一 个 NP 完 全 问题 ，
1])! 条 可 选 路 线 。

解 (1.3,2,4,1)， 最 优 值 是

ie /A Ee

回溯 法 对 解 空 间作 深度 优先 搜索 ， 因 此 ， 在 一 般 情况
下 用 递归 方法 实现 回溯 法 。

void backtrack ( int b/t 表 示 当 前 扩展 结 点 在 解 空 间 树 中 的 深度
{ if (t>n) output(x);/ 已 经 搜索 至 叶子 结 点 ， 输 出 可 行 解 x
else
for (int 1i=f(n,t);i<=g(n,t);i++)
{//£ (n, t) Allg (n, t 世 表示 当前 扩展 结 点 处 未 搜索 过 的 子 树 的 起 始 和 终止 编号
X[t]=h(i)3//h Gy) 表示 当前 扩展 结 点 处 x[t 的 第 i 个 可 选 值

if (constraint(t)&&bound(t)) //constraint (t) 和 bound(t) 表 示 当 前 扩展 结 点
处 的 约束 函数 和 限界 函数
backtrack(t+1);/ 对 相应 的 子 树 进行 搜索
AKER
RHE TEAR ER GI I, A ELE A
一 个 非 递归 迭代 过 程 。

void iterativeBacktrack ()
{ int t=1;
while (t>0) {
if (f(n,t)<=g(n,t))
for (int i=f(n,t);1<=g(n,t);i++) {
x[t]=h();
if (constraint(t)\&&bound(t)) {
if (solution(t))//solution (t) 判断 在 当前 扩展 结 点 处 是 否 已 得 到 问题 的 可 行 解
output(x):;// 当 前 扩展 结 点 处 xl1: 菇 是 问题 的 可 行 解 ， 输 出 可 行 解 x
else t++; // 当 前 扩展 结 点 处 xL1: 匡 只 是 问题 的 部 分 解 ， 纵 深 继续 搜索 】
}
else ft--:/ 约 束 函 数 和 限界 函数 都 不 满足 则 回溯

} 12
子 集 树 与 排列 树 BUA

0-1 背 包 问 题 旅行 售货员 问题 ()

遍历 子 集 树 需 O(2m) 计 算 时 间

void backtrack (int t) Void backtrack mt t)
{ {
if (t>n) output(x); if (t>n) output(x);
else else
for (int 1=0;i<=1;i++) { for (int I=t;i<=n;it++) {
x(t]=I; swap(x(t], x[!]);
if (legal(t)) backtrack(t+1); if (legal(t)) backtrack(t+1);
} ape x{i]));

} 13
me 0) eld

问题 描述 ， 有 一 批 共 n 个 集装箱 要 装 上 2 船 载

的 轮胎， 其 中 集 猴 箱 i 的 重

量 为 w; 》 且 Sw,

重量 分 别 为 cj 和 c。

<c, +c,

装载 问题 要 求 确 定 是 否 有 一 个 合理 的 装载 方案 可 将 这 个 集装箱
竣 上 这 2 用 轮 般 。 如 果 有 ， 找 出 一 种 雄 载 方案 。

容易 证 明 ， 如 宋 一 个 给 定 交 载 问题 有 解 ， 则 采用 下 面 的 介 略 可
得 到 取 优 雄 载 方案 。
(1) CFS 8 — A AS FY BERS TH
(2) “Kp SR as HSE ee FE Se ES PAG

Es — Fe AS AY Ee

MAT RE

Ase

装 箱

重量 之 和 最

满 等 价 于 选取 全 体 集 装 箱 的 一 个 子 集 ，

BiVtc,. Hast

BF AB REAR A O- Lr, IA jell

S.t. > WX, SC,
i=l

x, €{O.},l<isn

FY A, pea (Hy pel

e e % =|
ey lo) ee
“ 解 空 间 : 子 集 树
"可行 性 约束 函数 (选择 当前 元 素 ) > wx < c
。 当 前 载重 量 cw， 当 前 最 优 裁 重量 bestw, 集装箱 重量 数组 为 w[]

private static void backtrack (int 1)

{// 搜索 第 i 层 结 点
if(i > n){ / 到 达 叶 结 点
if ( cw > bestw ) bestw =cw; /更 新 最 优 解 bestw,
return;}
if (cw + wli] <= 0) AYIA: O(2"), ILA O(n)
{// 搜索 左 子 树 ,X[i]=1
cw += wi{i];
backtrack(i + 1);
cw -= wii];
} 1 0 1 0 1 a 1 0
backtrack(i+ 1), /搜索 石 了 树 a OG OG OG ©

}
Re
* 解 空间 : 子 集 树

“可 行 性 约束 函数 (选择 当前 元 素 ) ， 之 wz Se
“上 界 函 数 (不 选择 当前 元 素 ) ， BYR
当前 载重 量 cw+ 剩 余 集装箱 的 重量 r< 当 前 最 优 载重 量 bestw
private static void backtrack (int i)
{// 搜索 第 i 层 结 点
if(i > n){ / 到 达 叶 结 点

if ( cw > bestw ) bestw =cw; /更 新 最 优 解 bestw,
return;}

// 搜 索 子 树

r-= w([i];

if (cw + wii] <= c) (/ 搜索 左 子 树
cw += W[;
backtrack(i + 1);
cw -=wi[i];  }

if (cw +r>bestw) {/ 搜索 右 子 树
backtrack(i + 1); }

r += wii);

* e %
法 载 问题
“构造 最 优 解 : Ae I ae nar re ntte bestx 纪 有 孙 当 前 最 优 解
private static void backtrack (int |
{// 搜索 第 i 层 结 点
If (1 > nm){V 到 达 叶 结 点
if(cw>bestw){
forU=1;j<=nj++)
bestx[)]=x{)];
bestw=cw;}

pl 装载 问题 的 非 递 归 回 漳 算 法
// 搜 索 子 树 的 四 ots 测算

r-= will,
if (CW + wii] <= C) {

x[i] = 1; // 搜索 左 子 树
cw += wii];
backtrack(i + 1);
cw-= wii]; }

if (cw +r>bestw) {
x[i] = 0; / 搜索 右 子 树
backtrack(i+1);  } |

r += wii]; }

批 处 理 作业 调度

间 题 描述 :给 定 n 个 作业 的 集合 {，J，… 丁 } 。 每 个 作业 必须 先
由 机 器 1 处 理 ， 然 后 由 机 器 2 处 理 。 作 业 丁 需要 机 器 j 的 处 理 时 间
为 tii。 对 于 一 个 确定 的 作业 调度 ， 设 Fjj 是 作业 i 在 机 器 j 上 完成
处 理 的 时 间 。 所 有 作业 在 机 器 2 上 完成 处 理 的 时 间 和 称 为 该 作业
调度 的 完成 时 间 和 。

批 处 理 作 业 调 度 问 题 要 求 对 于 给 定 的 n 个 作业 ， 制 定 最 佳作 业
调度 方案 ， 使 其 完成 时 间 和 达到 最 小 。

ti NLatl 机 器 2
作业 1 2 1
作业 2 3 1
作业 3 2 3
作业 1 完成 时 间 和 ，

F,,+FtF)g=3+6+10=19

作业 2

作业 3 18

批 处 理 作业 调度

作业 1 2 1
作业 2 3 1
作业 3 2 3
作业 1
作业 3
作业 2 19 20 21 19 19
批 处 理 作业 调度 排列 树

完成 时 闻 和 H F21+F23+F22=3+7+8=18

% 1 3
HSE EWIRE

private static void backtrack(int )/ 第 ij 层 3} zt af af 2 1
{if (i> m) { 搜 索 至 叶子 结 点 YUMA C

for (int j = 1; j <= n; j++) bestx[j] = x[];/ 第 j 个 调度 作业 序号 x[j] 值 赋 给 当前 最 佳
作业 调度 bestx[j];

bestf =f; /bestf 为 当前 最 小 完成 时 间 和

}

else

for (int j = i; j <= n; j++) {MW 从 i 到 n 深 入
f1+=m[xf]l[1];V 当 前 作业 x0] 在 机 器 M1 上 完成 处 理 的 时 间
f2[]=((f2[i-1 人 >f1)?f2[-1]:f1)+m[xj[2];WM2 上 的 完成 处 理 时 间 (i 层 作业 )=maxff1，
ij-1 层 作业 在 M2 的 处 理 时 间 }#t 当 前 作业 x[] 在 M2 上 的 处 理 时 间
什 = 人 2[i]:

if f < bestf) { public class FlowShopy// 记 录 结 点 信息
~~ static int n, = // VEL Be
MyMath.swap(x,I,J); Wa 、
aoe. f1， V 机 器 1 完成 处 理 时 间
backtrack(i+1); f /完成 时 间 和
MyMath.swap(x,i,j): an

bestf; // 当前 最 优 值

static int [[ m; V 各 作业 所 需 的 处 理 时 间

和 static int 上 x; 当前 作业 调度
) ! static int [] bestx; / 当前 最 优 作 业 调 度

1 static int [] f2;  // 机 器 2 完成 处 理 时 间

oo 4-18
符号 三 角形 问题
问题 描述 : 下 图 是 由 14 个 “+2?” < BLAS “-” 组 成 的 符号 三 角

形 。2 个 同 号 下 面 都 是 “+”，2 个 异 号 下 面 都 是 “-”。 在 一
般 情 况 下 ， 符 号 三 角形 的 第 一 行 有 n 个 符号 。

+ + -+ - + +
+ - - - - +
- + + + -

- + + -

符号 三 角形 问题 要 求 对 于 给 定 的 n， 计 算 有 多 少 个 不 同 的 符号
三 角形 ， 使 其 所 含 的 “+” 和 “-” 的 个 数 相同 。

21
oOo 41-518
符号 三 角形 问题

。 解 问 量 : 用 n 元 组 x[1:o] 表 示 符 号 三 角形 的 第 一 行 。
@ 当 x[i=1 时 ， 表 示 符 号 三 角形 第 一 行 的 第 i 个 符号 为 “+?”;
@ 当 xf[i=0 时 ， 表 示 符 号 三 角形 第 一 行 的 第 i 个 符号 为 “-”; 1<=i<=n。
由 于 x 和 外 是 二 值 的 ， 所 以 可 以 用 一 棵 完全 二 叉 树 来 表示 解 空 间 。
@ 符 号 三 角形 的 第 一 行 前 ii 个 符号 x[l: 训 确定 后 ， 就 确定 了 一 个 由
ji(i+l)V2 个 符号 组 成 的 符号 三 角形 。
@ 在 确定 xLi+l] 的 值 后 ， 只 要 在 第 中 步 已 确定 的 符号 三 角形 的 右边 加 一 条
边 ， 就 可 以 扩展 为 xLl1:i+ji 所 相应 的 符号 三 角形 。
国 最 终 由 xll:n 所 确定 的 符号 三 角形 中 包含 “+” 号 个 数 与 “-” 个 数 同 为
n* (n+1) /4。
因此 ， 当 前 符号 三 角形 所 包含 的 “+” 个 数 与 “-” 个 数 均 不 超过 nx*Cn+1)/4 ©
“无 解 的 判断 ， 当 nx# (n+1) /72 为 奇数 时 ， 不 存在 包含 的 “+” 号 个 数 与 “-”
号 个 数 相 同 的 符号 三 角形 。
此 时 ， 可 通过 简单 的 判断 加 以 处 理 。

+ + -
+ -

Sil n=3, 符号 三 角 形
oe Am 日
符号 三 角形 问题
fA: 用 n 元 组 xlLl:n] 表 示 符 号 三 角形 的 第 一 行 。
可行 性 约束 函数 : 当前 符号 三 角形 所 包含 的 “+” 个 数 与 “-”
个 数 均 不 超过 nx (n+l)/4 。
“无 解 的 判断 : nx (n+1)72 为 奇数 。

private static void backtrack (int t)
{ if ((count>half)||(t*(t-1)/2-count>half)) return;

复杂 度 分 析

0(29 个 基点 需要 计算 可 行 性 约束， 故 解 符号 三
形 问题 的 回 湖 算 法 所 需 的 计算 时 间 为 Oo27。

if (

PEPPY ey oe 十 + .
countt= =plillt -j+1];
} +
backtrack(t+1); -
for (int j=2;j<=tjj++) count-=pfj][t-j+1]; ble n=3, 符号 三 角形

count-=!;
} 23
约束 函数

显 约束 :对 解 向 量 中 分 量 xi 的 取 值 限定 。
vv 装载 问题 的 显 约束 : wx < CI)

v 符 号 三 角形 问题 的 显 约束 :
当前 符号 三 角形 所 包含 的 “+ 个 数 与 “- 个 数 均 不 超过 m*(n+1)/4。

v 隐 约束 : ? ? ?
隐约 束 : 为 满足 问题 的 解 而 对 不 同 分 量 xi 之 间 施 加 的 约束 。

24
n 后 问题

问题 描述 :在 nxXn 格 的 棋盘 上 放置 彼此 不 受 攻 击 的 n 个 旺 后 。
按照 国际 象棋 的 规则 ， 星 后 可 以 攻击 与 之 处 在 同一 行 或 同一 列
或 同一 斜 线 上 的 棋子 。n 后 问题 等 价 于 在 nXn 格 的 棋盘 上 放置 n
个 旺 后 ， 任 何 2 个 旺 后 不 放 在 同一 行 或 同一 列 或 同一 和 斜 线 上 。

Q

Q

OND wm 和 上 wm
O

n 后 问题 分 析

1
2 _ ye
3 解 向 量 : (xX, Xqo vote x ) n 元 组 ，xf[i 计 表示
4 Fee BCE BE 8 i 47 Bx Li).
. BAR: x[ 订 取 值 范围 为 1, 2, 3……n。
6
7 隐约 束 :
8 1) 不 同 列 : x Lilex Lil;
12342678 2) 不 处 于 同一 正 、 反 对 角 线 。
fill: n=8 八 旦 后 问题
隐约 束 转化 为 显 约束 ，

1. nsn 格 棋 往 看 做 是 二 维 方 阵 ， 行 号 从 上 回 往 下 ， 列 号 从 左 往 右 编 号 为 1,2,3...n。

2. 左 上 角 到 右 下 角 的 主 对 角 线 及 其 平行 线 〈 和 斜率 为 -1) 上 ，“ 行 号 - 列 号 ”的 值 相等 。

3. 左 下 角 到 右上 角 的 主 对 角 线 及 其 平行 线 《〈 和 斜率 为 +1) 上 ，“ 行 号 + 列 号 ”的 值 相 等 。

4. 各 有 两 个 旺 后 ，《〈i，j) fl ck, D 表示 其 位 置 ， 备 Pj=k-| 或 者 i+j=k+l|， 则 说 明 两 个 旺
后 处 于 同一 斜 线 上 。 即 若 Pk=j-1 和 i-k=Hj 《|-kl=|il 成 立 ) ， 表 明 两 个 皇后 位 卖 同一
斜 线 上 。
n 后 问题 分 析

回溯 法 分 析 ;

@D 首 先 把 第 一 个 皇后 放 到 棋盘 上 ， 由 于 第 一 个 皇后
有 n 列 可 以 放 ， 因 此 可 扩展 出 n 种 情况 ， 先 选 其 中 一
列 放下 这 个 皇后 。

加 然后 开始 放 第 二 个 皇后 。 同 样 ， 第 二 个 皇后 也 有 mn
列 可 以 放 ， 因 此 也 能 扩展 出 n 种 情况 ， 但 是 第 二 个 皇
后 可 能 会 和 第 一 个 皇后 发 生 攻击 ， 而 一 且 攻 击 就 不
必要 往 下 扩展 第 三 个 皇后 ， 若 没有 发 生 攻 击 ， 则 继
续 放 第 三 个 皇后 。

LEY @@ 以 此 类 推 ， 直 到 n 个 皇后 全 部 都 放下 后 ， 即 得 到 一
>

@ 扩 展 全 部 完成 后 ， 就 得 到 了 结果 。

27
n 后 问题
* 解 向 量 : (x), Xo, 5 X)

1

“BAR: xi=1, 2，… ,nn <

“隐约 束 : 3
A
|

1) 不 同 列 : X {FX |
2) 不 处 于 同一 正 、 反 对 角 线 : | i-jl#|x,-x,
private static boolean place (int k)
WF EES AH BTR
for (int j=1;j<k;j++)
if ((Math.abs(k-j)==Math.abs(x{j]-x[k]))||(xJ]]==x[k])) return false;
return true;

123 4

}
private static void backtrack (int t)
if (t>n) SUm++;/ 到 达 叶 子 结 点 ， 方 案 增加 1。 eno
else ellhabdele :

for (int I=1;i<=n;i++) {
X[tj=i/ 列 的 取 值 有 1 到 n 种 情况
if (place(t)) backtrack(t+1);// 不 与 当前 冲突 ， 深 入 下 一 层 ， 继 续 28

}
例 n=4 BE

1 So
a | |
L. j
ae a f 4 oo
ca

29
fe: KE
“可 行 性 约束 函数 : SY wx <c
“LARA: 一

QO 设 [ 是 当前 剩余 物品 价值 的 总 和 ，
cp 是 当前 价值 ，bestp 是 当前 最
优 价值 。

@) 当 cp+r<=bestp 时 ， 可 以 前 去 右
FB

“上 界 函 数 : 更 优化 的 ?

思路 : 将 剩余 物品 按照 其 单位 重
量 价值 从 高 到 低 排序 ， 然 后 依次 闭
和 入， 直到 装 不 下 ， 再 装 入 该 物品 的
一 部 分 而 装 满 ， 因 此 得 到 的 价值 束
是 右 子 树 的 上 界 。

0-1 背 包 问 题

例 ，n=4，c=7，p=[9, 10, 7, 4],
w=[3, 5, 2, 1] 。

分 析 :

人 单位 重量 价值 为 [3, 2, 3. 5, 4] 。
@ 先 装 入 4， 再 装 入 3 和 1， 剩 余 容 量 为 1，
只 能 装 入 0. 2 的 物品 2。
@@ 得 到 解 x=[1 0. 2, 1 1] ， 最 优 价值 =22。
虽 不 可 行 ， 但 22 为 最 优 值 的 上 界 。

30
at > 一目
“0-1 背 包 问 题
fea]: 子 集 树 ”，
.可 行 性 约束 函数 ， > wx <c
。 上 界 函 数 : -
private static double bound(int 1)
{ 计算 上 界
double cleft=c-cw; /剩余 容量
double bound = cp;

// 以 物品 单位 重量 价值 递减 序 装 入 物品

while (i <= n && wifi] <= cleft)

{

cleft -= wii];

bound += pfi);//p[i A init iri YE: bound 计 算 当 前 结 点 处 的 上
I++; 界 ， 以 判断 是 否 将 右 子 树 剪 去 ，
} 进入 左 子 树 不 需要 计算 上 界 ， 其
MTS 上 界 与 父 结 点 相同 。

if(i<=n) bound += pfi] / wm”*cleft:
return bound;
0-149 ‘io Ei
fe: FH  ， 月 包 问 题
“可 行 性 约束 函数 ， 之 w 二 <
。 上 界 函 数 ，bound(inft i)

“递归 搜索 :

Private static void backtrack Cint iD
{

if(i>n) {// BH Be
bestn=cn-U- ait Mitt — AR tt

icy Wh LF ie O(N) TA), BID TAL FO(2")44 JL
子 结 点 需要 计算 上 界 ， 因 此 算法 backtrack 需 要 的
八 计算 时 间 征 On2?")
cw-=w[i];
cp-=pli];}
if(bound(i+1)>bestp)
backtrack(i+1);/ 进 入 右 子 树

32
图 的 m 着 色 问 题

图 的 m 可 着 色 判 定 问 题 : 给 定 无 回 连 通 图 G= (E, V) 和 m 种 不
同 的 颜色 。 用 这 m 种 颜色 为 图 G 的 各 顶点 着 色 ， 每 个 顶点 着
一 种 颜色 。 是 否 有 一 种 着 色 法 使 6" 中 每 条 边 的 2 个 顶点 着 不
同 颜色 。 这 个 问题 是 图 的 m 可 着 色 判 定 问 题 。

图 的 m 可 着 色 优 化 问题 : 和 若 一 个 岁 最 少 需要 m 种 颜色 才能
使 图 6G 中 每 条 边 连接 的 2 个 顶点 着 不 同 颜色 ， 则 称 这 个 数 m
为 该 图 的 色 数 。 求 一 个 图 的 色 数 m 的 问题 称 为 图 的 m 可 着

33

图 ， 地 图 和 相应 的 平面 图 ，
图 的 m 着 色 问 题

颜色 来 着 色 ， 使 得 相 邻 的 国家 在 地 图 上 着 不 同 颜色 。
Q) 假设 每 个 国家 在 地 图 上 是 单 连通 域 ;

四 色 猜 想 : 在 一 个 平面 或 者 球面 上 的 任何 地 图 能 够 只 用

种

@) 假设 2 个 国家 相 邻 是 指 这 2 个 国家 有 一 段 长 度 不 为 0 的 公

共 边 界 ， 不 仅仅 是 有 一 个 公共 氮 ， 这 样 的 地 图 容易 用 平
> a FE

面 图 表示 。
地 图 上 的 每 个 区 域 相应 于 平面 图 中 一 个 顶点 ，2 个
地 图 上 相 邻 ， 在 平面 图 中 相应 的 2 个 顶点 之 间 有 一 条 边 相 邻 。

例 : 下 图 为 一 个 有 5 个 区 域 的 地 图 及 其 相应 的 平面

个 地 图 需要 四 种 颜色 来 着 色 。

图 ， 地 图 和 相应 的 平面 图 ，

冬 | 。

34

这
问题

Hiss: WCC IA) ee

OmRixt EB
凶 如 果 这 个

分 析 :

OF
则 afi

冬

的 邻

[JF I,

(2) B01,2,

图 的 m 着 色 问 题

BFE Rha Ze NTC [ny EH

冬

G= (V, E) Ame ea
6 不 是 m 可 着 色 的 ， 给 出 否定 回答 。
色 可 以 m 着 色 ， 找 出 不 同 的 着 色 法 。

Go 4G, 起 属于

否则 ai]j]=0《 人 多 al1][2]=1，a[1][5]=0 )
...m 表 示 m 种 不 同 颜色 〈 例 ， 苦 =1， 绿 =2， 紫 =3， 红 =4) ;
@ 顶 点 ji 所 着 颜色 用 xfi] 表 示 〔〈 例 : x[1]=1， x[2]= 2, x[3]=3， x[4]= 4，
x[5]=1 ) 。

图 ， 地 图 和 相应 的 平面 图 ，

i

6 的 边 集 P，

35
图 的 m 着 色 问 题

问题 描述 ， 设 无 同 连 通 图 G=(V E) 和 m 种 颜色 ;
中 如 果 这 个 图 6 不 是 m 可 着色 的 ， 给 出 否定 回答 。
包 如 果 这 个 图 可 以 m 着 色 ， 找 出 不 同 的 着 色 法 。

解 向 量 : (xi, Xo, ... , x ) 表 示 顶 点 ji 所 着 颜色 x[i] 。
解 空 间 : 高 为 n+1 的 完全 m 又 树 。

解 衬 间 树 的 第 i 层 中 每 一 个 结 点 都 有 m 个 儿子 ;
@ 每 个 儿子 相应 于 X[i] 的 m 个 可 能 的 着 色 之 一 。

例 : 下 图 为 n=3，m=3 的 问题 的 解 空间 树 。

可
x{1]=1 5 3

z[2F1 2] 3
3 ©. i 3 Ss. ( (3 ©. (3

“BE LATS
SIO COB OOO OOO COO OOO OOO COD
el: n=3，m-3 问 题 的 解 空 间 树

36
图 的 m 着 色 问 题

*“ 解 癌 量 : (X,,X, .…，xn) 表 示 顶 点 ji 所 着 颜色 x[i]。
“可 行 性 约束 函数 : sty LE CURSE

private static void backtrack(int t)
也 搜 索 第 t 层 子 树

by
of 复杂 度 分 析

对 于 每 个 内 结 点 ， 在 最 坏 情况 下 ， 用 ok 检查 当 ae
HUA REAR RAM BE Bh JL PA A i A PE

roy
Ra}
°

* | petnto Gon) «te, IRE WIN FEE
bo ym (mn) = nm(m" —1) (m=1) = O(n")
priv
He yy

for (int j=1;j<=n;j++)
if (a[k][j] && (x{j]==x[k])) return false;

[2]= 2) 3
return true;

xl
}
回溯 法 效率 分 析

通过 前 面具 体 实 例 的 讨论 容易 看 出 ， 回 调 算 法 的 效
率 在 很 大 程度 上 依赖 于 以 下 因素 :
(1) P=4Ex [k] AYE Ted
(2) Wie ALBARN x Tk AS 2X
(3) 计算 约束 函数 constraint 的 时 间 ;
(4) 计算 上 界 函 数 bound 的 时 间 ;
(5) 满足 约束 函数 和 上 界 函 数 约 束 的 所 有 x[kj] 的 个 数 。

aati aera ena eo 但 这
样 的 约束 角 数 往往 计算 量 较 大 。 在 选择 约束 函
数 时 通常 存在 4 ROA Bes PGR CAL

折衷。

38
重 排 原 理

对 于 许多 问题 而 言 ， 在 搜索 试探 时 选取 X[ij 的 值 顺序 是 任意 的 。
在 其 他 条 件 相当 的 前 提 下 ， 让 可 取 值 最 少 的 x[i] 优 先 。 从 图 中
天 于 同一 问题 的 2 株 不 同 解 空 间 树 ， 可 以 体会 到 这 种 稼 略 的 淤 力 。

we et. gg

roa o7o oOo O7O WO OO (b)
O00 0000 000000 00 COO O0 00000

Alay, MRE RT, UU AT DY 75 RS 370A
一 次 消去 12 个 3 元 组 。 对 于 图 (b)， 虽 然 同 样 从 第 1 层 剪 去 1 棵 子
树 ， 却 只 从 应 当 考 碟 的 3 元 组 中 消去 8 个 3 元 组 。 前 者 的 效 末 明
显 比 后 者 好 。

小 结

> 回溯 法 是 一 个 既 带 有 系统 性 又 带 有 跳跃 性 的 搜索 算法 ;

” 瑟 在 包含 问题 的 所 有 解 的 解 空间
策略 ， 从 根 结 点 出 发 搜索 解 空 间
” 算法 搜索 至 解 空间 树 的 任 一 线 点

树 中 ， 按 照 深度 优先 的
树 。 一 一 系统 性
时 ， 判 断 该 结 点 为 根 的

子 树 是 否 包含 问题 的 解 ， 如 果 肯 定 不 包含 ， 则 跳 过 以 该

结 点 为 根 的 子 树 的 搜索 ， 逐 层 回
， 进 入 该 子 树 ， 继 续 深 度 优先 的
BREE

SSCA SL. PM
SRM TET 15228 0 ——Bb

> 这 种 以 深度 优先 的 方式 系统 地 搜索 问题 的 解 得 算法 称 为

避 漳 法 ， 它 适用 于 解 一 些 组 合 数 较 大 的 问题 。

40
小 结

m ARE:
。 搜索 从 开始 结 点 《 根 结 点 ) 出 发 ， 以 深度 优先 搜索 整个 解 空间 。

"。 这 个 开始 结 点 成 为 活 结 点 ， 同 时 也 成 为 当前 的 扩展 绪 点 。 在 当前 的
扩展 结 点 处 ， 搜 索 同 纵深 方 问 移 至 一 个 新 结 点 。 这 个 新 结 点 就 成 为
新 的 活 结 点 ， 并 成 为 当前 扩展 结 氮 。

© 如 末 在 当前 的 扩展 络 氮 处 不 能 再 网 纵深 方 风 扩展， 则 当前 扩展 结 点
就 成 为 死结 点 。

*。 JER, DES) CBD 至 最 近 的 一 个 活 结 点 处 ， 并 使 这 个 活络
点 成 为 当前 的 扩展 结 点 ;直到 找到 一 个 解 或 全 部 解 。

国 二 类 常见 的 解 空 间 树 :， 子 集 树 ， 排 列 树 。
当 所 给 问题 是 从 n 个 元 素 的 集合 S 中 找 出 S 满 足 某 种 性 质 的 子 集 时 ，

相应 的 解 空 间 称 为 子 集 树 。 O(2")
= Pr er | ed A) PB En 7 BA A PE J AE EY, DY AY FE 28 1]
树 称 为 排列 树 。 O(n!)

四 回溯 法 实现 方法 : GVA, AR.
m SPM: 约束 函数 ， 限 界 函 数 。

41

