第4章 贪心算法

1

第4章 贪心算法
学习要点
 理解贪心算法的概念
 掌握贪心算法的基本要素
（1）最优子结构性质
（2）贪心选择性质
 通过应用范例学习贪心设计策略

2

问题提出
例：货币兑付问题。

银行出纳员支付一定量的现金，其手中有各种
面值的货币，要求用最少的货币张数来支付现金。

3

第4章 贪心算法
顾名思义，贪心算法总是作出在当前看来最好的
选择。也就是说贪心算法并不从整体最优考虑，它所
作出的选择只是在某种意义上的局部最优选择。
当然，希望贪心算法得到的最终结果也是整体最
优的。虽然贪心算法不能对所有问题都得到整体最优
解，但对许多问题它能产生整体最优解。如:单源最短
路经问题等。
在一些情况下，即使贪心算法不能得到整体最优
解，其最终结果却是最优解的很好近似。如:多机调度
问题。
4

第4章 贪心算法
本章主要知识点：
4.1 活动安排问题
4.2 贪心算法的基本要素
4.3 最优装载
4.4 哈夫曼编码
4.5 单源最短路径
4.6 多机调度问题

5

4.1 活动安排问题
问题描述：设有n个活动的集合E={1,2,…,n}，其中每
个活动都要求使用同一资源，如演讲会场等，而在同一
时间内只有一个活动能使用这一资源。要求高效的安排
这个争用公共资源的活动。
“相容”的定义：每个活动i都有一个要求使用该资源
的起始时间si和一个结束时间fi,且si <fi 。如果选择了
活动i，则它在半开时间区间[si, fi)内占用资源。若区
间[si, fi)与区间[sj, fj)不相交，则称活动i与活动j是
相容的。也就是说，当sj≥fi或si ≥ fj时，活动i与活
动j相容。
活动安排问题：要在所给活动集合E中选出最大的相容
活动子集A。
贪心算法提供了一个简单、漂亮的方法使得尽可能多的
活动能兼容地使用公共资源。

6

4.1 活动安排问题
在下面所给出的解活动安排问题的贪心算法greedySelector :

public static int greedySelector(int [] s, int [] f, boolean a[])
{
int n=s.length-1;
a[1]=true;
int j=1;
int count=1;
//依次检查活动i是否与当前已选择的所有活动相容
for (int i=2;i<=n;i++){
// 相容
if (s[i]>=f[j]) {//f[j]为当前集合A中所有活动的最大结束时间
a[i]=true;//活动在集合A中当且仅当a[i]=true
j=i;//j记录最近一次加入活动集A的活动
count++;
}
//不相容
else a[i]=false;
}
return count;
}

各活动的起始时
间和结束时间存
储于数组s和f中
且按结束时间
的非减序排列

7

4.1 活动安排问题
由于输入的活动以其完成时间的非减序排列，所
以算法greedySelector每次总是选择具有最早完成时
间的相容活动加入集合A中。直观上，按这种方法选
择相容活动为未安排活动留下尽可能多的时间。也就
是说，该算法的贪心选择的意义是使剩余的可安排时
间段极大化，以便安排尽可能多的相容活动。
算法效率分析：算法greedySelector的效率极高。当
输入的活动已按结束时间的非减序排列，算法只需
O(n)的时间安排n个活动，使最多的活动能相容地使
用公共资源。如果所给出的活动未按非减序排列，可
以用O(nlogn)的时间重排。
8

4.1 活动安排问题
例：设待安排的11个活动的开始时间和结束时间按结
束时间的非减序排列如下：

i



s[i] 1



4.1 活动安排问题
i
算法greedySelector
的计算过程如左图所示。
图中每行相应于算法的
一次迭代。
阴影长条表示的活动是
已选入集合A的活动。
空白长条表示的活动是
当前正在检查相容性的
活动。
10

4.1 活动安排问题
若被检查的活动i的开始时间si小于最近选择的活
动j的结束时间fj，则不选择活动i，否则选择活动i加
入集合A中。
贪心算法并不总能求得问题的整体最优解。但对
于活动安排问题，贪心算法greedySelector却总能求
得的整体最优解，即它最终所确定的相容活动集合A的
规模最大。这个结论可以用数学归纳法证明。

11

4.1 活动安排问题
数学归纳法证明：
设集合E={1,2,…,n}为所给活动的集合。E中活动
按结束时间非减序排列。活动1具有最早完成时间。
证明1：活动安排问题有一个最优解以贪心选择开始，
即，该最优解包含活动1。
证明：
设A  E是所给活动安排的一个最优解，且A中的活动
也按结束时间非减序排列，A中的第一个活动为活动k。
⑴若k=1，则A就是以贪心选择开始的最优解。
⑵若k>1, 设B=A-{k}∪{1}。因f1 ≤ fk,且A中活动是
相容的，故B中活动也相容。又B中活动个数与A中活动
个数相同，且A是最优的，B也是最优的。
得证，B是以贪心选择活动1开始的最优活动安排。
12

4.1 活动安排问题
数学归纳法证明：
设集合E={1,2,…,n}为所给活动的集合。E中活动
按结束时间非减序排列。活动1具有最早完成时间。
证明2：贪心选择活动1后，原问题简化为对E集合中所
有与活动1相容的活动进行活动安排的子问题。即若A
是原问题的最优解，则A’=A-{1}是活动安排问题
E’={i  E|si≥f1}的最优解。
证明：
若能找到E’的一个解B’,它包含比A’更多的活动，
则将活动1加入B’中将产生E的一个解B，它包含的活
动比A更多，因此这与A是最优解矛盾。
因此，每一步做出的贪心选择都将原问题简化为一
个更小的与原问题具有相同形式的子问题。
13

4.2 贪心算法的基本要素
本节着重讨论可以用贪心算法求解的问题的一般
特征。
对于一个具体的问题，怎么知道是否可用贪心算
法解此问题，以及能否得到问题的最优解呢?这个问题
很难给予肯定的回答。
但是，从许多可以用贪心算法求解的问题中看到
这类问题一般具有2个重要的性质：贪心选择性质和最
优子结构性质。

14

4.2 贪心算法的基本要素
1.贪心选择性质
所谓贪心选择性质是指所求问题的整体最优解可
首先，考查问题的
一个整体最优解，并
以通过一系列局部最优的选择，即贪心选择来达到。
证明可修改这个最优
这是贪心算法可行的第一个基本要素，也是贪心算法
解，使其以贪心选择
与动态规划算法的主要区别。
开始。其次，在贪心
选择后，原问题简化
动态规划算法通常以自底向上的方式解各子问题，
为规模更小的类似子
而贪心算法则通常以自顶向下的方式进行，以迭代的
问题。归纳证明通过
方式作出相继的贪心选择，每作一次贪心选择就将所
每一步的贪心选择，
求问题简化为规模更小的子问题。 最终可得到问题的整
体最优解。

对于一个具体问题，要确定它是否具有贪心选择
性质，必须证明每一步所作的贪心选择最终导致问题
的整体最优解。
15

4.2 贪心算法的基本要素
2.最优子结构性质
当一个问题的最优解包含其子问题的最优
解时，称此问题具有最优子结构性质。
问题的最优子结构性质是该问题可用动态
规划算法或贪心算法求解的关键特征。

16

4.2 贪心算法的基本要素
3.贪心算法与动态规划算法的差异
贪心算法和动态规划算法都要求问题具有最优子
结构性质，这是2类算法的一个共同点。
但是，对于具有最优子结构的问题应该选用贪心
算法还是动态规划算法求解?是否能用动态规划算法求
解的问题也能用贪心算法求解?
下面研究2个经典的组合优化问题，并以此说明贪
心算法与动态规划算法的主要差别。

17

4.2 贪心算法的基本要素
0-1背包问题：
给定n种物品和一个背包。物品i的重量是Wi，其
价值为Vi，背包的容量为C。应如何选择装入背包的物
品，使得装入背包中物品的总价值最大?
在选择装入背包的物品时，对每种物品i只有2种选择，即装入
背包或不装入背包。不能将物品i装入背包多次，也不能只装入
部分的物品i。

18

4.2 贪心算法的基本要素
背包问题：
与0-1背包问题类似，所不同的是在选择物品i装
入背包时，可以选择物品i的一部分，而不一定要全部
装入背包，1≤i≤n。
这2类问题都具有最优子结构性质，极为相似，但
背包问题可以用贪心算法求解，而0-1背包问题却不能
用贪心算法求解。
19

4.2 贪心算法的基本要素
用贪心算法解背包问题的基本步骤：
首先计算每种物品单位重量的价值Vi/Wi，然后，依贪心
选择策略，将尽可能多的单位重量价值最高的物品装入背包。
若将这种物品全部装入背包后，背包内的物品总重量未超过
C，则选择单位重量价值次高的物品并尽可能多地装入背包。
依此策略一直地进行下去，直到背包装满为止。
具体算法可描述如下页：

20

4.2 贪心算法的基本要素

public static float knapsack(float c,float [] w, float [] v,float [] x)
{
int n=v.length;
Element [] d = new Element [n];
for (int i = 0; i < n; i++) d[i] = new Element(w[i],v[i],i);
MergeSort.mergeSort(d);//物品按照单位价值排序
int i;
float opt=0;
for (i=0;i<n;i++) x[i]=0;//初始化
for (i=0;i<n;i++) {//贪心选择单位重量价值高的物品加入
if (d[i].w>c) break;
x[d[i].i]=1;
opt+=d[i].v;
c-=d[i].w;
}
if (i<n){//部分装入背包
x[d[i].i]=c/d[i].w;
opt+=x[d[i].i]*d[i].v;
}
return opt;
}

算法knapsack的
主要计算时间在于
将各种物品依其单
位重量的价值从大
到小排序。因此，
算法的计算时间上
界为
O（nlogn）。当然，
为了证明算法的正
确性，还必须证明
背包问题具有贪心
选择性质。

21

4.2 贪心算法的基本要素
算法分析：对于0-1背包问题，贪心选择之所以不能得
到最优解是因为在这种情况下，它无法保证最终能将背包
装满，部分闲置的背包空间使每公斤背包空间的价值降低
了。
事实上，在考虑0-1背包问题时，应比较选择该物品
和不选择该物品所导致的最终方案，然后再作出最好选择。
由此就导出许多互相重叠的子问题。这正是该问题可用动
态规划算法求解的另一重要特征。
实际上也是如此，动态规划算法的确可以有效地解0-1
背包问题。
22


1.￥60 2.￥100 3.￥120 4.背包

100
20 60
10
=￥220

60
10

=￥160 =￥180

120
——×20
30

100
20
60
10
=￥240

0-1背包问题的例子
23

4.3 最优装载
问题描述：有一批集装箱要装上一艘载重量为c的轮船。
其中集装箱i的重量为wi。最优装载问题要求确定在装
载体积不受限制的情况下，将尽可能多的集装箱装上
轮船。
n

该问题可形式化描述为:

max  xi
i 1

其中变量xi=0表示不装入集装箱i，
xi=1表示装入集装箱i。

n

w x  c
i 1

i i

xi  {0，
1}，
1 i  n
24

4.3 最优装载
1.算法描述
最优装载问题可用贪心算法求解。
采用重量最轻者先装的贪心选择策略，可产生最
优装载问题的最优解。具体算法描述如下页。

25

4.3 最优装载

public static float loading(float c, float [] w, int [] x)
{
int n=w.length;
Element [] d = new Element [n];
for (int i = 0; i < n; i++)
d[i] = new Element(w[i],i);
MergeSort.mergeSort(d);
float opt=0;
for (int i = 0; i < n; i++) x[i] = 0;
for (int i = 0; i < n && d[i].w <= c; i++) {
x[d[i].i] = 1;
opt+=d[i].w;
c -= d[i].w;
其中Element类说明为参
}
return opt;
见本书P115
}
26

4.3 最优装载
2.贪心选择性质
可以证明最优装载问题具有贪心选择性质。

3.最优子结构性质
最优装载问题具有最优子结构性质。
由最优装载问题的贪心选择性质和最优子结构性
质，容易证明算法loading的正确性。
算法loading的主要计算量在于将集装箱依其重量
从小到大排序，故算法所需的计算时间为 O(nlogn)。

27

4.4 哈夫曼编码
哈夫曼编码是广泛地用于数据文件压缩的十分有
效的编码方法。其压缩率通常在20%～90%之间。
用字符在文件中出现的频率表来建立一个用0，1
串表示各字符的最优表示方式。
给出现频率高的字符较短的编码，出现频率较低
的字符以较长的编码，可以大大缩短总码长。

28

例：

定长码需：300000位
变长码需：（45*1+13*3+12*3+16*3+9*4+5*4）*1000=
224000位 ——最优编码方案

1.前缀码
对每一个字符规定一个0,1串作为其代码，并要求
任一字符的代码都不是其他字符代码的前缀。这种编
码称为前缀码。
编码的前缀性质可以使译码方法非常简单。
29

最优前缀码
平均码长定义： B(T ) 

 f (c)d (c)
cC

T

C为编码字符集，f(c)表示C中任一字符c以频率
f(c)在文件中出现。
C的一个前缀码编码方案对应一棵二叉树T，字符c
在树T中的深度为 dT (c)（也是字符c的前缀码长）。

使平均码长达到最小的前缀码编码方案称为给定
编码字符集C的最优前缀码。
30

最优前缀码

定长码

变长码（最优前缀码）

表示最优前缀码的二叉树总是一棵完全二叉树，即树
中任一结点都有2个儿子结点。
最优前缀码的完全二叉树中，恰有|C|个叶子结点，每 31
个叶子结点对应字符集C中的一个字符。

4.4 哈夫曼编码
2.构造哈夫曼编码
哈夫曼提出构造最优前缀码的贪
心算法，由此产生的编码方案称为哈
夫曼编码。
哈夫曼算法以自底向上的方式构
造表示最优前缀码的二叉树T。
算法以|C|个叶结点开始，执行
|C|－1次的“合并”运算后产生最终

所要求的树T。
最优前缀码二叉树

32

例

4.4 哈夫曼编码
算法huffmanTree中，编码字符集中每一字
符c的频率是f(c)。算法思想：
1.初始化以频率f为键值的优先队列Q。O(n)
2.贪心的选择具有最小频率的2棵树x和y，
将其合并（初始时，单节点树）。
O(logn)
3.两棵具有最小频率的树x和y合并后，产生
一棵新的树z。
4.z树的频率为合并的2棵树的频率之和。
5.将新树z据频率f插入优先队列Q。 O(logn)
6.不断重复上述操作，经过n－1次的“合并”
后，优先队列Q中只剩下一棵树，即所要求的树T。
34

4.4 哈夫曼编码
算法huffmanTree用最小堆实现优先队列Q。
 初始化优先队列需要O(n)计算时间；
 最小堆的removeMin（最小频率树）和put（插入优先队列）运
算均需O(logn)时间，n－1次的合并总共需要O(nlogn)计算时
间。
 因此，关于n个字符的哈夫曼算法的计算时间为O(nlogn)。

3.哈夫曼算法的正确性
要证明哈夫曼算法的正确性，只要证明最优前缀码问题具
有贪心选择性质和最优子结构性质。

35

(1)贪心选择性质（证明）
设C是编码的字符集，C中的字符c的频率为f(c)；x和y是
C中具有最小频率的两个字符。
求证：存在C的最优前缀码，使得x和y具有相同最长
码长，且只有最后一位编码不同。

T树为表示C的任何一个最优前缀码。
设 f(b) ≤ f(c), f(x) ≤ f(y)；
且f(x) ≤ f(b), f(y) ≤ f(c)。

做相应变化后，能证明T’’ 树表示的前缀
码也是C的最优前缀码。
36

(1)贪心选择性质（证明）

树T到树T’ 的平均码长之差：
B(T)-B(T’)   f (c)d T (c)   f (c )dT ' (c )
cC

cC

 f ( x ) d T ( x )  f (b) d T (b)  f ( x ) d T ' ( x )  f (b) d T ' (b)
 f ( x ) d T ( x )  f (b) d T (b)  f ( x ) d T (b)  f (b) d T ( x )
 ( f (b)  f ( x ))( d T (b)  d T ( x ))
0

因此，B(T) ≥ B(T’) 。

交换T’树中y和c的位置得T’ ’，同理得， B(T’) ≥ B(T’ ’).
B(T’ ’) ≤ B(T’) ≤ B(T)，与假设的T为表示C的一个最优前缀码矛盾。因此，
B(T)= B(T’ ’) ， T’ ’树也表示最优前缀码，而且以x和y这两个最小频率的字
符作为最深叶子节点，且为兄弟。

37

(2)最优子结构性质（证明）
设T是表示字符集C的一个最优前缀码的完全二叉树，C中的字符c的频率为f(c)；
x和y是树T中的两个叶子且为兄弟，z是他们的父亲。
若z看作是具有频率f(z)=f(x)+f(y)的字符，则树T’=T-{x,y}表示字符集C’=C-{x,y} ∪{z}
的一个最优前缀码。
证明：首先，证明T的平均码长B(T)可用T’的平均码长B(T’)表示。
对于任意的 c  C-{x,y}，有 dT (c)  dT (c) ,所以 f (c) dT (c)  f (c) dT (c)
dT ( x )  dT ( y )  dT ( z )  1 ，所以
'

'

'

f ( x)dT ( x)  f ( y )dT ( y )  ( f ( x)  f ( y ))( dT ' ( z )  1)
 f ( x )  f ( y )  f ( z ) dT ' ( z )
'
故， B(T )  B(T )  f ( x)  f ( y) 。

若T’所表示的字符C’的前缀码不是最优的,则设有T’’表示的C’的前缀码使B(T’’) < B(T’) 。
由于z被看做是C’中的一个字符，因此z在T’’中是一树叶。
将x和y加入T’’作为z的儿子，则得到表示字符集C的前缀码的二叉树T’’’.
B (T ''' )  B (T '' )  f ( x )  f ( y )
 B (T ' )  f ( x )  f ( y )
 B (T )
B (T ''' )  B (T )

这与T的最优性矛盾，因此T’表示的字符集C’的前缀码是最优的。

38

4.5 单源最短路径
问题描述：给定带权有向图G =(V,E)，其中每条边的
权是非负实数。另，给定V中的一个顶点，称为源。现
要计算从源到所有其他各顶点的最短路径长度。这里
路径长度是指路上各边权之和。这个问题通常称为单
源最短路径问题。

1.算法基本思想
Dijkstra算法是解单源最短路径问题的贪心算法。

39

4.5 单源最短路径
算法基本思想是：设置顶点集合S并不断地作贪心
选择来扩充这个集合。一个顶点属于集合S当且仅当从
源到该顶点的最短路径长度已知。
1.初始时，S中仅含有源。
2.带权有向图G =(V,E)，设u是G的某一个顶点，
把从源到u且中间只经过S中顶点的路称为从源到u的特
殊路径，并用数组dist记录当前每个顶点所对应的最
短特殊路径长度。
3.Dijkstra算法每次从V-S集合中取出具有最短特
殊路长度的顶点u，将u添加到S中，同时对数组dist作
必要的修改。
4.一旦S包含了所有V中顶点，dist就记录了从源
40
到所有其他顶点之间的最短路径长度。

4.5 单源最短路径
例如，对右图中的
有向图，应用Dijkstra
算法计算从源顶点1到其
他顶点间最短路径的过
程列在下页的表中。

41

4.5 单源最短路径
Dijkstra算法的迭代过程：
迭代


Dijkstra算法思想：
（1）假设用带权的邻接矩阵edges 来表示带权有向图G =(V,E) ，edges[i][j] 表
示弧〈vi, vj〉上的权值 。若〈vi, vj〉不存在，则置edges[i][j]为∞（在计算机上可用
允许的最大值代替）。
S为已找到从源v出发的最短路径的终点vi的集合，它的初始状态为空集。那么，
从源v出发到图G上其余各顶点（终点）vi可能达到最短路径长度的初值为：
D[i]= edges[Locate Vex(G,v)][i] vi∈V
（2）选择vj，使得
D[j]=Min{D[i]| vi∈V-S}
vj就是当前求得的一条从v出发的最短路径的终点。令
S＝S∪{j}
（3）修改从v出发到集合V-S上任一顶点vk可达的最短路径长度。如果
D[j]+ edges[j][k]<D[k]
则修改D[k]为
D[k]=D[j]+ edges[j][k]
重复操作（2）、（3）共n-1次。由此求得从v 到图上其余各顶点vi的最短路径是依
路径长度递增的序列。
43

4.5 单源最短路径
2.算法的正确性和计算复杂性
(1)贪心选择性质
(2)最优子结构性质
(3)计算复杂性
对于具有n个顶点和e条边的带权有向图，如果用
带权邻接矩阵表示这个图，那么Dijkstra算法的主循
环体需要 O (n)时间。这个循环需要执行n-1次，所以完
2
O
(
n
) 时间。算法的其余部分所需要时间不
成循环需要
2
超过 O(n ) 。
44

4.6 多机调度问题
多机调度问题要求给出一种作业调度方案，使所
给的n个作业在尽可能短的时间内由m台机器加工处理
完成。
约定，每个作业均可在任何一台机器上加工处理，但未完
工前不允许中断处理。作业不能拆分成更小的子作业。

这个问题是NP完全问题，到目前为止还没有有效
的解法。对于这一类问题,用贪心选择策略有时可以设
计出较好的近似算法。

45

4.6 多机调度问题
采用最长处理时间作业优先的贪心选择策略可以
设计出解多机调度问题的较好的近似算法。
按此策略，当 n  m 时，只要将机器i的[0, ti]
时间区间分配给作业i即可，算法只需要O(1)时间。
当 n  m 时，首先将n个作业依其所需的处理
时间从大到小排序。然后依此顺序将作业分配给空闲
的处理机。算法所需的计算时间为O(nlogn)。

46

4.6 多机调度问题
例如，设7个独立作业{1,2,3,4,5,6,7}由3台机
器M1，M2和M3加工处理。各作业所需的处理时间分
别为{2,14,4,16,6,5,3}。按算法greedy产生的作业
调度如下图所示，所需的加工时间为17。

47

小结
贪心算法：总是作出在当前看来最好的选
择，而不从整体最优考虑。它所作出的选择只
是在某种意义上的局部最优选择。
贪心算法不能对所有问题都得到整体最优
解，但对许多问题它能产生整体最优解。如单
源最短路经问题，最小生成树问题等。在一些
情况下，即使贪心算法不能得到整体最优解，
其最终结果却是最优解的很好近似。
48

贪心法基本要素
适合贪心法求解的问题，一般具有性质：
– 贪心选择性质
– 最优子结构性质

贪心选择性质
– 问题的全局最优，可以通过一系列局部最优的选
择来达到。

49

例：出纳员兑付问题
集合P={p1,p2,…,p60}表示出纳员手中货币，集合元素分别表示：
10元、5元、1元、5角、2角、1角各10张。
集合X={x1,x2,…,x60}表示出纳员支付给客户的货币。
假设支付数为57元8角，并使付出货币数量最少。
第一步：所挑选的货币集合是S1={p1}，得局部最优Y1=(1,0,…)
问题简化为在集合P1={p2,…,p60}挑选货币，付出47元8角给客户
这样一个子问题。
后续步：用上述方法进行，可得问题最优解。

最优子结构：一个问题最优解中包含子问题最优解。

∪

上列最优解Sn={p1,p2,p3,p4,p5,p11,p21,p22,p31,p41,p51}
第一步所简化了的子问题的最优解是：
Sn-1={p2,p3,p4,p5,p11,p21,p22,p31,p41,p51}
显然： Sn-1 Sn中 ，且Sn-1∪{p1}=Sn
所以，出纳员付钱问题具有最优子结构性质。
50

货郎担问题


每次都贪心的选择最小费用路线：
1→4→3→5→2→1（14）
实际，从城市1出发最优路线：
1→2→5→4→3→1（13）
贪婪法解决货郎担问题时，不具有
最优子结构性质及贪心选择性质。

从许多可以用贪心算法求解的问题中看到这类问
题一般具有2个重要的性质：
贪心选择性质和最优子结构性质。
51

贪心法设计思想
贪心法通常解决最大、最小问题。
基本思想：
从某一初始态出发，根据当前局部最优
而不是全局最优决策，以满足约束方程为条
件，以使得目标函数值增加最快或最慢为准
则，选择一个能够最快地达到要求的输入元
素，以便尽快地构成问题地可行解。
52

假定有n张面值为pi的货币，1≤i≤n，用集合P={pi1,pi2,….., pin}表示。
假定支付的现金数为A，则须从P选取最下的子集S，使得:
pi∈S 且 ∑pi=A
用向量X=(x1 ,x2,…,xn)表示从S中所选取的货币，使得：
xi=

1 pi∈S
0 pi∈S

则出纳支付现金必须满足：
∑xipi=A
(1)
并且使得：
d＝min∑xi
(2)
称向量X为问题的解向量。
由于xi取值为0或1，故有2n个不同向量，把所有这些向量的全体称为
问题解空间。
(1)式称为问题的约束方程。
(2)式称为问题的目标函数。
满足(1)式的向量解称为问题可行解，满足(2)式的向量称为最优解。
53

上述问题归结：
在问题的解空间，搜
索满足约束方程且使得目
标函数达极值的解向量。
贪心法在某种程度上
是解决此类问题的简单有
效方法！！！

54

设计方法描述
贪心算法由一个
Greedy(A,n) {
迭代循环组成。
solution=null;
通过局部少量计
for(i=1;i<n;i++) {
算，试图寻求一
个局部最优解。
x=select(A);
每一步都极大地增
if(feasible(solution,x))
长了它所希望实现
地目标函数。
solution=union(solution,x)
}
Return solution;
困难：证明所设计算法
}

是问题的最优解。

55

能够使用贪心算法的问题必须满足下
面的两个性质：
1.整体的最优解可以通过局部的最优
解来求出；
2.一个整体能够被分为多个局部，并
且这些局部都能够求出最优解。

56

