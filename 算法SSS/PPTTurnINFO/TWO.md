第2章

递归与分治策略

1

2.1

递归的概念

• 直接或间接地调用自身的算法称为递归算法。
• 用函数自身给出定义的函数称为递归函数。
• 递归分类：
– 直接
– 间接
• 递归本质：对原问题求解转化为同质子问题求解。

2

2.1

递归的概念

例1 阶乘函数
阶乘函数可递归地定义为：

边界条件

n0
 1
n! 
n(n  1)! n  0
递归方程
边界条件与递归方程是递归函数的二个要素，递归函
数只有具备了这两个要素，才能在有限次计算后得出
结果。

3

2.1

递归的概念

•递归技术分为两类
-基于归纳法
-基于分治法
•基于归纳法递归思想：
对于一个规模为n的问题P(n)，归纳法的思想方法是：
(1)基础步:a1是问题P(1)的解
(2)归纳步:对1<k<n，若b是问题P(k)的解，则p(b)是问题P(k+1)的
解。
求P(n)的解an，则先求P(n-1)的解an-1 ,...,不断的递归求解直到P(1)。
得到P(1)的解后，返回来，进行所得解的P(2)运算，直到得到P(n)
的解。

4

2.1

递归的概念

• 例2 多项式求值递归算法
n阶多项式：
Pn(x)=anxn+an-1xn-1+…+a1x+a0
公式改成：

Pn(x)=((…((an)x)+an-1)x+an-2)x+…+a1)x+a0
递归：
(1)基础步：n＝0，有p0＝a0
(2)归纳步：对任意k，1≤ k ≤ n，前面k步已经算出pk-1:

pk-1(x)=anxk-1+an-1xk-2+…+an-k+2x+an-k+1
则有：pk(x)=xpk-1(x)+an-k
5

2.1

递归的概念

例2 多项式求值递归算法
输入：A[], x, n
输出：值
```java
public Float horner_pol(float A[ ],float x,int n) {
If(n==0)
p=A[0];
Else
p=horner_pol(A, x,n-1)*x+A[n];
Return p
}
算法时间复杂性：
f(0)=0
f(n)=f(n-1)+1 → f(n)=O(n)
6
```

2.1

递归的概念

例3 Fibonacci 数列
无穷数列1，1，2，3，5，8，13，21，34，55，…，被
称为Fibonacci 数列。它可以递归地定义为：

1
n0


F ( n)  
1
n 1
F (n  1)  F (n  2) n  1

第n个Fibonacci 数可递归地计算如下：
public static int fibonacci(int n)
{
if (n <= 1) return 1;
return fibonacci(n-1)+fibonacci(n-2);
}

边界条件

递归方程

7

2.1
例4

递归的概念

Ackerman 函数

当一个函数及它的一个变量是由函数自身定义时，称
这个函数是双递归函数。

Ackerman函数A(n，m)定义如下：

A(1,0)  2


A(0, m)  1
m0


A(n,0)  n  2
n2

 A(n, m)  A( A(n  1, m), m  1) n, m  1

8

2.1

递归的概念

例4 Ackerman 函数
前2例中的函数都可以找到相应的非递归方式定义：

n! 1  2  3    (n  1)  n
n 1
n 1






1  1 5
1 5





F ( n) 






2
2
5 


 


但本例中的Ackerman函数却无法找到非递归的定义。
9

2.1

递归的概念

例4 Ackerman 函数
• A(n，m)的自变量m的每一个值都定义了一个单变量函数：
• M=0时，A(n,0)=n+2
• M=1时，A(n,1)=A(A(n-1,1),0)=A(n-1,1)+2，和A(1,1)=2故
A(n,1)=2*n
• M=2时，A(n,2)=A(A(n-1,2),1)=2A(n-1,2)，和
A(1,2)=A(A(0,2),1)=A(1,1)=2，故A(n,2)= 2n 。
• M=3时，类似的可以推出

2

2
2

2
n

• M=4时，A(n,4)的增长速度非常快，以至于没有适当的数学式子
来表示这一函数。
10

2.1

递归的概念

例4 Ackerman 函数
• 定义单变量的Ackerman函数A(n)为A(n)=A(n,n)。
• 定义其拟逆函数α(n)为：α(n)=min{k|A(k)≥n}。
即α(n)是使n≤A(k)成立的最小的k值。
• α(n)在复杂度分析中常遇到。对于通常所见到
的正整数n，有α(n)≤4。但在理论上α(n)没有上
界，随着n的增加，它以难以想象的慢速度趋
向正无穷大。

11

2.1

递归的概念

例5 排列问题
设计一个递归算法生成n个元素{r1,r2,…,rn}的全排列。
设R={r1,r2,…,rn}是要进行排列的n个元素，Ri=R-{ri}。
集合X中元素的全排列记为perm(X)。
(ri)perm(X)表示在全排列perm(X)的每一个排列前加上前缀
得到的排列。R的全排列可归纳定义如下：
当n=1时，perm(R)=(r)，其中r是集合R中唯一的元素；
当n>1时，perm(R)由(r1)perm(R1)，(r2)perm(R2)，…，
(rn)perm(Rn)构成。

12

2.1

递归的概念

例6 整数划分问题
将正整数n表示成一系列正整数之和：n=n1+n2+…+nk，
其中n1≥n2≥…≥nk≥1，k≥1。
正整数n的这种表示称为正整数n的划分。求正整数n的不
同划分个数。
例如：正整数6有如下11种不同的划分：
6；
5+1；
4+2，4+1+1；
3+3，3+2+1，3+1+1+1；
2+2+2，2+2+1+1，2+1+1+1+1；
1+1+1+1+1+1。
13

2.1
–

–
–

递归的概念

前面的几个例子中，问题本身都具有比较明显的递归
关系，因而容易用递归函数直接求解。
在本例中，如果设p(n)为正整数n的划分数，则难以找
到递归关系。
因此考虑增加一个自变量：将最大加数n1不大于m的划
分个数记作q(n,m)。可以建立q(n,m)的如下递归关系：
1) q(n,1)=1，n≥1；当最大数n1不大于1时，任何正整数n只有一种
划分形式：n=1+1+...+1(共n个)。
2) q(n,m)=q(n,n)，m≥n；最大加数n1实际上不能大于n。因此，
q(1,m)=1。
3) q(n,n)=1+q(n,n-1)；正整数n的划分由n1=n的划分和n1≤n-1的划
分组成。
4) q(n,m)=q(n,m-1)+q(n-m,m),n>m>1；正整数n的最大加数n1不大
于m的划分由n1=m的划分和n1≤m-1的划分组成。
14

2.1
例6

递归的概念

整数划分问题

可以建立q(n,m)的如下递归关系:

1


q(n, n)

q(n, m)  
1  q(n, n  1)

q(n, m  1)  q(n  m, m)

n  1, m  1
nm
nm
n  m 1

正整数n的划分数p(n)=q(n,n)。
15

2.1

递归的概念

例7 Hanoi塔问题
设A, B, C是3个塔座。开始时，在塔座A上有一叠共n个圆盘，
这些圆盘自下而上，由大到小地叠在一起。各圆盘从小到大编号
为1, 2, …, n,现要求将塔座A上的这一叠圆盘移到塔座B上，并仍按
同样顺序叠置。在移动圆盘时应遵守以下移动规则：
规则1：每次只能移动1个圆盘；

规则2：任何时刻都不允许将较大的圆盘压在较小的圆盘之上；
规则3：在满足移动规则1和2的前提下，可将圆盘移至A, B, C中任一
塔座上。

16

2.1

递归的概念

• 算法思想：
(1) 基础步：n=1，将A上圆盘移到B上
(2) 归纳步：n>1时，将n-1个较小圆盘依照规则从塔A移到塔C，
将塔A最大圆盘移到塔B。再将n-1个较小圆盘依照规则从塔C
移到塔B。
• 结论：
n个圆盘的移动问题可分为2次n-1个圆盘的移动题，这又
可以递归地用上述方法来做。由此可以设计出解Hanoi塔问
题的递归算法如下。

17

2.1

递归的概念

例6 Hanoi塔问题
public static void hanoi(int n, int a, int b, int c)
在问题规模较大时，较难找到一般的方法，因此我们尝试
当n=1时，问题比较简单。此时，只要将编号为1的圆盘从塔座a直
用递归技术来解决这个问题。
接移至塔座b上即可。
{
思考题：如果塔的个数变为A, B, C,
当n＞1时，需要利用塔座c作为辅助塔座。此时若能设法将n-1个
if (n > 0)
D 四个，现要将n个圆盘从A全部移
较小的圆盘依照移动规则从塔座a移至塔座c，然后，将剩下的最
{
动到D，移动规则不变，求移动步数
大圆盘从塔座a移至塔座b，最后，再设法将n-1个较小的圆盘依照
hanoi(n-1, a, c, b);
最小的方案。
移动规则从塔座c移至塔座b。
move(a,b);
由此可见，n个圆盘的移动问题可分为2次n-1个圆盘的移动问题，
hanoi(n-1, c, b, a);
这又可以递归地用上述方法来做。由此可以设计出解Hanoi塔问题
的递归算法如下。
}
}

18

Hanoi算法分析
• 假设h(n)是移动n个盘子的移动次数
(1)当n=1时，显然只移动一次，h(1)=1；
(2)当n=2时，将小盘移到C，把大盘移到B，再将小盘
移到B。移动次数： h(2)= 2h(1)+1
• 依次类推，可得递归关系：
h(1)=1
h(n)=2 h(n-1)+1→2n-1→h(n)=O(2n)

19

19

递归小结
优点：结构清晰，可读性强，而且容易用数学归纳法来
证明算法的正确性，因此它为设计算法、调试程序带
来很大方便。
缺点：递归算法的运行效率较低，无论是耗费的计算时
间还是占用的存储空间都比非递归算法要多。

20

递归小结
解决方法：在递归算法中消除递归调用，使其转化为非
递归算法。
1.采用一个用户定义的栈来模拟系统的递归调用工作栈。
该方法通用性强，但本质上还是递归，只不过人工做
了本来由编译器做的事情，优化效果不明显。
2.用递推来实现递归函数。
3.通过Cooper变换、反演变换能将一些递归转化为尾递
归，从而迭代求出结果。
后两种方法在时空复杂度上均有较大改善，但其适用
范围有限。
21

线性递归:
long Rescuvie(long n) {
return(n == 1) ? 1 : n * Rescuvie(n - 1);
}
尾递归:
long TailRescuvie(long n, long a) {
return(n == 1) ? a : TailRescuvie(n - 1, a * n);
}
Rescuvie(5)
{5 * Rescuvie(4)}
{5 * {4 * Rescuvie(3)}}
{5 * {4 * {3 * Rescuvie(2)}}}
{5 * {4 * {3 * {2 * Rescuvie(1)}}}}
{5 * {4 * {3 * {2 * 1}}}}
{5 * {4 * {3 * 2}}}
{5 * {4 * 6}}
{5 * 24}

TailRescuvie(5,1)
TailRescuvie(5, 1)
TailRescuvie(4, 5)
TailRescuvie(3, 20)
TailRescuvie(2, 60)
TailRescuvie(1, 120)

22

分治思想的提出
假设C(x)为描述问题x的复杂度的函数，E(x)为解决问题x的代
价函数。
根据经验，对于两个问题p1和p2，如果
C(p1) > C(p2) 那么 E(p1) > E(p2)
进一步得出如下推论：
C(p1+p2) > C(p1) + C(p2)

E(p1+p2) > E(p1) + E(p2)
因此推断，如果问题P能够分解为n个子问题，那么解决n个
子问题的总代价肯定低于直接解决P的代价，因为P太复杂了，
让人无从下手！

23

分治算法
•• 对这k个子问题分别求解。如果子问题的规模仍然不够
将要求解的较大规模的问题分割成k个更小规模的子问
小，则再划分为k个子问题，如此递归的进行下去，直
题。
到问题规模足够小，很容易求出其解为止。

递归树

T(n)

=

T(n/2)

n

T(n/2)
24

分治算法
•• 将求出的小规模的问题的解合并为一个更大规模的问
对这k个子问题分别求解。如果子问题的规模仍然不够
题的解，自底向上逐步求出原来问题的解。
小，则再划分为k个子问题，如此递归的进行下去，直
到问题规模足够小，很容易求出其解为止。

=

T(n)

n

n/2

n/2

T(n/4)

T(n/4)

T(n/4)

T(n/4)

25

分治算法
• 将求出的小规模的问题的解合并为一个更大规模的问
题的解，自底向上逐步求出原来问题的解。

=

T(n)
T(n)

n
n

n/2

T(n/4)

n/2

T(n/4)

T(n/4)

T(n/4)

26

分治法算法总体思想
• 分治法的基本思想
–分治法的基本思想是将一个规模为n的问题分解为k个规
模较小的子问题，这些子问题互相独立且与原问题相同。
–对这k个子问题分别求解。如果子问题的规模仍然不够小，
则再划分为k个子问题，如此递归的进行下去，直到问题
规模足够小，很容易求出其解为止。
–将求出的小规模的问题的解合并为一个更大规模的问题
的解，自底向上逐步求出原来问题的解。
–分治法的设计思想是，将一个难以直接解决的大问题，
分割成一些规模较小的相同问题，以便各个击破，分而
治之。（divide-and-conquer）
27

分治法的适用条件
分治法所能解决的问题一般具有以下几个特征：
• 该问题的规模缩小到一定的程度就可以容易地解决；
• 该问题可以分解为若干个规模较小的相同问题，即该
问题具有最优子结构性质
• 利用该问题分解出的子问题的解可以合并为该问题的
解；
• 该问题所分解出的各个子问题是相互独立的，即子问
题之间不包含公共的子问题。
这条特征涉及到分治法的效率，如果各子问题是不
因为问题的计算复杂性一般是随着问题规模的增加
这条特征是应用分治法的前提，它也是大多数问题
能否利用分治法完全取决于问题是否具有这条特征，
而增加，因此大部分问题满足这个特征。
可以满足的，此特征反映了递归思想的应用
如果具备了前两条特征，而不具备第三条特征，则
独立的，则分治法要做许多不必要的工作，重复地
可以考虑贪心算法或动态规划。
解公共的子问题，此时虽然也可用分治法，但一般
用动态规划较好。
28

分治法的基本步骤
divide-and-conquer(P)
{
if ( | P | <= n0) adhoc(P); //解决小规模的问题
divide P into smaller subinstances P1,P2,...,Pk；//分解问题
for (i=1,i<=k,i++)
yi=divide-and-conquer(Pi); //递归的解各子问题
return merge(y1,...,yk); //将各子问题的解合并为原问题的解
}
人们从大量实践中发现，在用分治法设计算法时，最好使
子问题的规模大致相同。即将一个问题分成大小相等的k个子问
题的处理方法是行之有效的。这种使子问题规模大致相等的做
法是出自一种平衡(balancing)子问题的思想，它几乎总是比子
问题规模不等的做法要好。
29

分治法的复杂性分析
一个分治法将规模为n的问题分成k个规模为n／m的子问题去
解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时
间。再设将原问题分解为k个子问题以及用merge将k个子问题的
解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法
解规模为|P|=n的问题所需的计算时间，则有：

O(1)
n 1

T ( n)  
kT (n / m)  f (n) n  1
通过迭代法求得方程的解： T (n)  n

logm k



logm n 1

j
j
k
f
(
n
/
m
)

j 0

注意：递归方程及其解只给出n等于m的方幂时T(n)的值，但
是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可
以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当
30
mi≤n<mi+1时，T(mi)≤T(n)<T(mi+1)。

二分搜索技术
给定已按升序排好序的n个元素a[0:n-1]，现要在这n个元素中找
出一特定元素x。
 该问题的规模缩小到一定的程度就可以容易地解决；
分析：
 该问题可以分解为若干个规模较小的相同问题;
 分解出的子问题的解可以合并为原问题的解；
 分解出的各个子问题是相互独立的。
分析：如果n=1即只有一个元素，则只要比较这个元素和x就
分析：比较x和a的中间元素a[mid]，若x=a[mid]，则x在L中的
可以确定x是否在表中。因此这个问题满足分治法的第一个适
位置就是mid；如果x<a[mid]，由于a是递增排序的，因此假
分析：很显然此问题分解出的子问题相互独立，即在a[i]的前
用条件
如x在a中的话，x必然排在a[mid]的前面，所以我们只要在
面或后面查找x是独立的子问题，因此满足分治法的第四个适
a[mid]的前面查找x即可；如果x>a[i]，同理我们只要在a[mid]
用条件。
的后面查找x即可。无论是在前面还是后面查找x，其方法都
和在a中查找x一样，只不过是查找的规模缩小了。这就说明
31
了此问题满足分治法的第二个和第三个适用条件。

二分搜索技术
给定已按升序排好序的n个元素a[0:n-1]，现要在这n个元素中找
出一特定元素x。
算法复杂度分析：
据此容易设计出二分搜索算法：
public static int binarySearch(int [] a, int x, int n)
{
// 在 a[0] <= a[1] <= ... <= a[n-1] 中搜索 x
// 找到x时返回其在数组中的位置，否则返回-1
int left = 0; int right = n - 1;
while (left <= right) {
int middle = (left + right)/2;
if (x == a[middle]) return middle;
if (x > a[middle]) left = middle + 1;
else right = middle - 1;
}
return -1; // 未找到x
}

每执行一次算法的
while 循 环 ， 待 搜 索 数
组的大小减少一半。因
此，在最坏情况下，
while 循 环 被 执 行 了
O(logn) 次。循环体内
运算需要O(1) 时间，因
此整个算法在最坏情况
下的计算时间复杂性为
O(logn) 。

思考题：给定a，用二分法设计出求an的算法。 32

二分搜索技术
1
n 1


T n   T  n   1 n  1
 

 2
T 1  1
T 2   T 1  1  2
T 4   T 2   1  3

T n 




 





T 2 m  T 2 m 1  1
m  1  log n  1  Olog n 
33

大整数的乘法
请设计一个有效的算法，进行两个n位二进制整数的乘法运算
小学的方法：O(n2)
分治法:

效率太低

X =复杂度分析 a
Y=

b
O(1)
n 1

T ( n)  
n 1
c4T (n / 2)  O(n) d
T(n)=O(n2) 没有改进

X = a 2n/2 + b

Y = c 2n/2 + d

XY = ac 2n + (ad+bc) 2n/2 + bd
34

大整数的乘法
请设计一个有效的算法，可以进行两个n位大整数的乘法运算
小学的方法：O(n2)
效率太低
分治法:
复杂度分析
O(1)
n 1

n/2 + bd
XY = ac T2(nn)+ (ad+bc)
2
3T (n / 2)  O(n) n  1

为了降低时间复杂度，必须减少乘法的次数。
T(n)=O(nlog3) =O(n1.59)较大的改进

1. XY = ac 2n + ((a-b)(c-d)+ac+bd) 2n/2 + bd
2. XY = ac 2n + ((a+b)(c+d)-ac-bd) 2n/2 + bd
细节问题：两个XY的复杂度都是O(nlog3)，但考虑到a+c, b+d可
能得到m+1位的结果，使问题的规模变大，故不选择第2种方案。
35

大整数的乘法
请设计一个有效的算法，可以进行两个n位大整数的乘法运算
小学的方法：O(n2)

分治法: O(n1.59)
更快的方法??

效率太低
较大的改进

如果将大整数分成更多段，用更复杂的方式把它们组合起来，
将有可能得到更优的算法。
 最终的，这个思想导致了快速傅利叶变换(Fast Fourier
Transform)的产生。该方法也可以看作是一个复杂的分治算法，
对于大整数乘法，它能在O(nlogn)时间内解决。
是否能找到线性时间的算法？？？目前为止还没有结果。
36

Strassen矩阵乘法
传统方法：O(n3)
n

A和B的乘积矩阵C中的元素C[i, j]定义为: C[i ][ j ]   A[i ][ k ]B[k ][ j ]
k 1

若依此定义来计算A和B的乘积矩阵C，则每计算
C的一个元素C[i][j]，需要做n次乘法和n-1次加
法。因此，算出矩阵C的n2个元素所需的计算时
间为O(n3).
37

Strassen矩阵乘法
传统方法：O(n3)
分治法:
使用与上例类似的技术，将矩阵A，B和C中每一矩阵都分块成4
复杂度分析
O(1)
n2
个大小相等的子矩阵。由此可将方程C=AB重写为：

T (nC)  C
 11 812T(n /A211) AO
n
 B211) nB12 2
12 (
C C    A
 B

A
B
22 
22   21
22 
 21 T(n)=O(n
 321) 没有改进
由此可得：

C11  A11 B11  A12 B21
C12  A11 B12  A12 B22
C21  A21 B11  A22 B21
C22  A21 B12  A22 B22

38

Strassen矩阵乘法
传统方法：O(n3)
分治法:
为了降低时间复杂度，必须减少乘法的次数。
复杂度分析

C12   AO11(1)A12   B11 nB12 2
C

11
T (n
)


C C8

n
 B2 ) nB  2
7
T
(
n
/
2
)

O
(
A
A
22   21
22 
 21  22   21
log7) =O(n2.81)较大的改进
M1  A11 ( B12 T(n)=O(n
B22 )
C11  M 5  M 4  M 2  M 6
M 2  ( A11  A12 ) B22
M 3  ( A21  A22 ) B11

M 4  A22 ( B21  B11 )
M 5  ( A11  A22 )( B11  B22 )
M 6  ( A12  A22 )( B21  B22 )
M 7  ( A11  A21 )( B11  B12 )

C12  M1  M 2
C21  M 3  M 4
C22  M 5  M 1  M 3  M 7
39

Strassen矩阵乘法
传统方法：O(n3)
分治法: O(n2.81)
更快的方法??
Hopcroft和Kerr已经证明(1971)，计算2个２×２矩阵的乘积，
7次乘法是必要的。因此，要想进一步改进矩阵乘法的时间复
杂性，就不能再基于计算2×2矩阵的7次乘法这样的方法了。
或许应当研究３×３或５×５矩阵的更好算法。
在Strassen之后又有许多算法改进了矩阵乘法的计算时间复
杂性。目前最好的计算时间上界是 O(n2.376).

是否能找到O(n2)的算法？？？目前为止还没有结果。
40

棋盘覆盖
问题描述：在一个2k×2k 个方格组成的棋盘中，恰有一个方格与
其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊
棋盘。
在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖
给定的特殊棋盘上除特殊方格以外的所有方格，且任意2个L型
骨牌不得重叠覆盖。

41

棋盘覆盖
构造同质子问题思路：
当k>0时，将2k×2k棋盘分割为4个2k-1×2k-1 子棋盘(a)所示。
特殊方格必位于4个较小子棋盘之一中，其余3个子棋盘中无
特殊方格。
为了将这3个无特殊方格的子棋盘转化为特殊棋盘，可以
用一个L型骨牌覆盖这3个较小棋盘的会合处，如(b)所示，从
而将原问题转化为4个较小规模的棋盘覆盖问题。
递归地使用这种分割，直至棋盘简化为棋盘1×1。

42

棋盘覆盖

dr < tr + s && dc < tc + s

左上角子棋盘

dr < tr + s && dc >= tc + s 右上角子棋盘
dr >= tr + s && dc < tc + s 左下角子棋盘
dr >= tr + s && dc >= tc + s 右下角子棋盘

tr棋盘左上角行号
tc棋盘左上角列号
dr特殊方格的行号
dc特殊方格的列号
s棋盘大小, 2k
43

棋盘覆盖
public void chessBoard(int tr, int tc, int dr, int dc, int size)
{
board[tr + s - 1][tc + s] = t;
if (size == 1) return;
// 覆盖其余方格
int t = tile++, // L型骨牌号
chessBoard(tr, tc+s, tr+s-1, tc+s, s);}
s = size/2; // 分割棋盘
// 左下角子棋盘
// 左上角子棋盘
if (dr >= tr + s && dc < tc + s)
if (dr < tr + s && dc < tc + s)
// 特殊方格在此棋盘中
复杂度分析
// 特殊方格在此棋盘中
chessBoard(tr+s, tc, dr, dc, s);
O
(
1
)
k号L型骨牌覆盖右上角
0

chessBoard(tr, tc, dr, dc, s);
else
{//
用
t
T (k ) 
else {// 此棋盘中无特殊方格 4T (k  1) board[tr
O(1) +ks][tc
 0+ s - 1] = t;

// 用 t 号L型骨牌覆盖右下角
// 覆盖其余方格
k
board[tr + s - 1][tc T(k)=O(4
+ s - 1] = t; ) 渐进意义下的最优算法
chessBoard(tr+s, tc, tr+s, tc+s-1, s);}
// 覆盖其余方格
// 右下角子棋盘
chessBoard(tr, tc, tr+s-1, tc+s-1, s);}
if (dr >= tr + s && dc >= tc + s)
// 右上角子棋盘
// 特殊方格在此棋盘中
if (dr < tr + s && dc >= tc + s)
chessBoard(tr+s, tc+s, dr, dc, s);
// 特殊方格在此棋盘中
else {// 用 t 号L型骨牌覆盖左上角
chessBoard(tr, tc+s, dr, dc, s);
board[tr + s][tc + s] = t;
else {// 此棋盘中无特殊方格
// 覆盖其余方格
// 用 t 号L型骨牌覆盖左下角
chessBoard(tr+s, tc+s, tr+s, tc+s);}
}

快速排序
快速排序是对气泡排序的一
种改进方法
它是由C.A.R. Hoare于1962
年提出的

在快速排序中，记录的比较和交换是从两端向中间
进行的，关键字较大的记录一次就能交换到后面单
元，关键字较小的记录一次就能交换到前面单元，
记录每次移动的距离较大，因而总的比较和移动次
数较少。

private static void qSort(int p, int r)
{
if (p<r) {
int q=partition(p,r); //以a[p]为基准元素将a[p:r]划分成3
段a[p:q-1],a[q]和a[q+1:r]，使得a[p:q-1]中任何元素小于等
于a[q]，a[q+1:r]中任何元素大于等于a[q]。下标q在划分过
程中确定。
qSort (p,q-1); //对左半段排序
qSort (q+1,r); //对右半段排序
}
45
}

快速排序
private static int partition (int p, int r)
{
{6, 7, 5, 2, 5, 8}
int i = p,
j = r + 1;
{6, 7, 5, 2, 5, 8}
Comparable x = a[p];
j
i
// 将>= x的元素交换到左边区域
// 将<= x的元素交换到右边区域
{5, 7, 5, 2, 6, 8}
while (true) {
j
i
while (a[i].compareTo(x) < 0) {i ++;}
while (a[--j].compareTo(x) > 0);
{5, 6, 5, 2, 7, 8}
if (i >= j) break;
j
i
MyMath.swap(a, i, j);
{5, 2, 5, 6, 7, 8}
}
i j
}

初始序列

j--;
i++;
j--;
i++;

{5, 2, 5} 6 {7, 8} 完成

a[i]  x  a[ j ]

?

快速排序具有不稳定性。 46

快速排序
快速排序算法的性能取决于划分的对称性。通过修
改算法partition，可以设计出采用随机选择策略的快速
排序算法。
2)
最坏时间复杂度：O(n
在快速排序算法的每一步中，当数组还没有被划分
平均时间复杂度：O(nlogn)
时，可以在a[p:r]中随机选出一个元素作为划分基准，这
辅助空间：O(n)或O(logn)
样可以使划分基准的选择是随机的，从而可以期望划分
是较对称的。
稳定性：不稳定
private static int randomizedPartition (int p, int r)
{
int i = random(p,r);
MyMath.swap(a, i, p);
return partition (p, r);
}
47

最接近点对问题
问题简化：为了使问题易于理解和分析，先来考虑一维的情
问题描述：给定平面上n个点的集合S，找其中的一对点，使
形。此时，S中的n个点退化为x轴上的n个实数 x1,x2,…, xn。最
得在n个点组成的所有点对中，该点对间的距离最小。
接近点对即为这n个实数中相差最小的2个实数。
问题求解：
假设我们用x轴上某个点m将S划分为2个子集S1和S2 ，基于平
将每一点与其他n-1个点的距离算出，找出达到最小距离
衡子问题的思想，用S中各点坐标的中位数来作分割点。
的2个点即可。
递归地在S1和S2上找出其最接近点对{p1, p2}和{q1, q2}，并设
d=min{|p1-p2|,|q1-q2 2|}，S中的最接近点对或者是{p1,p2}，或者是
算法效率：O（n
）
{q1,q2} ，或者是某个{p3,q3}，其中p3∈S1且q3∈S2。

能否在线性时间内找到p3, q3？
实际意义：空中交通控制。

48

最接近点对问题
能否在线性时间内找到p3,q3 ？
如果S的最接近点对是{p3,q3 }，即|p3-q3|<d，则p3和q3两者与m
的距离不超过d，即p3∈(m-d,m]，q3∈(m,m+d]。
由于在S1中，每个长度为d的半闭区间至多包含一个点（否则
必有两点距离小于d），并且m是S1和S2的分割点，因此(m-d,m]
中至多包含S中的一个点。由图可以看出，如果(m-d,m]中有S
中的点，则此点就是S1中最大点。
因此，我们用线性时间就能找到区间(m-d,m]和(m,m+d]中所
有点，即p3和q3 。从而我们用线性时间就可以将S1的解和S2的
解合并成为S的解,即O(n)。


49

最接近点对问题


下面来考虑二维的情形。

选取一垂直线l:x=m来作为分割直线。其中m为S中各点x坐标
的中位数。由此将S分割为S1和S2。
递归地在S1和S2上找出其最小距离d1和d2 ，并设d=min{d1, d2}，
S中的最接近点对或者是d，或者是某个{p, q}，其中p∈P1且
q∈P2。

能否在线性时间内找到p, q？

50

最接近点对问题
能否在线性时间内找到p, q？
考虑P1中任意一点p，它若与P2中的点q构成最接近点对的候
选者，则必有distance(p，q)＜d。满足这个条件的P2中的点一
定落在一个d×2d的矩形R中。
由d的意义可知，P2中任何2个S中的点的距离都不小于d。由
此可以推出矩形R中最多只有6个S中的点。
因此，在分治法的合并步骤中最多只需要检查6×n/2=3n个候
选者
证明:将矩形R的长为2d的边3等分，将它的长为d
的边2等分，由此导出6个(d/2)×(2d/3)的矩形。
若矩形R中有多于6个S中的点，则由鸽舍原理易
知至少有一个(d/2)×(2d/3)的小矩形中有2个以上
S中的点。设u，v是位于同一小矩形中的2个点，
则
( x(u )  x(v)) 2  ( y (u )  y (v)) 2  (d / 2) 2  (2d / 3) 2 
51

distance(u, v)<d。这与d的意义相矛盾。

25 2
d
36

最接近点对问题
为了确切地知道要检查哪6个点，可以将p和
P2中所有S2的点投影到垂直线l上。由于能与p
点一起构成最接近点对候选者的S2中点一定在
矩形R中，所以它们在直线l上的投影点距p在l
上投影点的距离小于d。由上面的分析可知，
这种投影点最多只有6个。
因此，若将P1和P2中所有S中点按其y坐标排
好序，则对P1中所有点，对排好序的点列作一
次扫描，就可以找出所有最接近点对的候选者。
对P1中每一点最多只要检查P2中排好序的相继
6个点。
52

最接近点对问题
4. 设P1是S1中距垂直分割线l的距离在dm之内的
所有点组成的集合；
{
P2是S2中距分割线l的距离在dm之内所有点
n=|S|;
组成的集合；
将P1和P2中点依其y坐标值排序；
if (n < 2) 复杂度分析
return ;
O(1)
n4
并设X和Y是相应的已排好序的点列；
T (n) 5. 通过扫描X以及对于X中每个点检查Y中与其
1. m=S中各点x间坐标的中位数;

2T (n / 2)  O(n) n  4

构造S1和S2；
距离在dm之内的所有点(最多6个)可以完成合并；
T(n)=O(nlogn)
当X中的扫描指针逐次向上移动时，Y中的
//S1={p∈S|x(p)<=m},
扫描指针可在宽为2 dm的区间内移动；
S2={p∈S|x(p)>m}
设dl是按这种扫描方式找到的点对间的最小
2. d1=cpair2(S1);
距离；
6. d=min(dm, dl);
d 2=cpair2(S2);
return d;
3. dm=min(d1,d2);
}
public static double cpair2(S)

53

循环赛日程表
设计一个满足以下要求的比赛日程表：
(1)每个选手必须与其他n-1个选手各赛一次；
(2)每个选手一天只能赛一次；
(3)循环赛一共进行n-1天。
按分治策略，将所有的选手分为两半，n个选手的比赛日程表
就可以通过为n/2个选手设计的比赛日程表来决定。递归地用
对选手进行分割，直到只剩下2个选手时，比赛日程表的制定
就变得很简单。这时只要让这2个选手进行比赛就可以了。

