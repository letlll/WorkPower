算法设计与分析
 <编号> 
 王良君 
 18952886643 
 计算机528 
 <编号> 
 问题1 
 我们为什么要了解算法设计与分析？ 
 <编号> 
 算法是计算机理论和实践的核心, 在已经逐步进入信息化社会的今天,算法的基本知识、方法、思想日益融入人们社会生活的方方面面,已经也应该成为现代人所应具备的一种基本素质. 
 理由1 
 <编号> 
 <编号> 
 算法学习有助于我们全面的理解运算能力 
 理由2 
 <编号> 
 输入：正整数m，n 
 输出：m，n的最大公因子 
 Int euclid(int m,int n) 
 { 
 int r; 
 do { 
 r = m%n; 
 m = n; 
 n = r; 
 } while(r) 
 return m; 
 } 
 例1 欧几里德：求两个数最大公因子算法 
 <编号> 
 公元5世纪末，古代数学家张丘建在所撰写的《算经》中，提出问题： 
 鸡翁一，值钱五；鸡母一，值钱三；鸡雏三，值钱一。百钱买百鸡，问 
 鸡翁、母、雏各几何？ 
 令a为公鸡只数，b为母鸡只数，c为小鸡只数，根据题意立方程： 
 a+b+c=100 
 5a+3b+c/3=100 
 c%3=0 
 这类问题用解析法求解有困难，但可采用穷举法求解。 
 例2 百鸡问题 
 <编号> 
 输入： 
 输出： 
 Void chicken_question(int n) 
 { int a,b,c; 
 for(a=0;a<=n;a++){ 
 for(b=0;b<=n;b++){ 
 for(c=0;c<=n;c++){ 
 if((a+b+c=n)&&(5*a+3*b+c/3=100)&&(c%3)=0) 
 printf(a,b,c); 
 } } } } 
 分析： 
 执行时间取决于内循环执行次数。外循环执行次数n＋1次；中间循环执行次数(n+1)(n+1)；内循环执行次数(n+1)(n+1)(n+1)。 
 当n=100时，总执行次数＝(100+1)*(100+1)*(100+1)= 1013 。 
 <编号> 
 考虑到n钱只能买到n/5只公鸡， 或n/3只母鸡，有些组合可以不考虑。 
 改进算法： 
 Void chicken_question(int n) 
 { int a,b,c; 
 for(a=0;a<=n/5;a++){ 
 for(b=0;b<=n/3;b++){ 
 c=n-a-b; 
 if((a+b+c=n)&&&&(c%3)=0) 
 printf(a,b,c); 
 } } } 
 分析： 
 内循环执行次数(n/5+1)(n/3+1)。 
 当n=100时，总执行次数＝(100/5+1)*(100/3+1)=714。 
 <编号> 
 某售货员要到若干个城市销售货物，已知各城市间距离，要求售货员选择出发的城市及旅行路线，使每个城市只经过一遍，最后回到出发地，而总路程最短。 
 分析： 
 每一条路线对应于城市编号1,2…n的一个排列。n个城市就会有n！个不同的路线，只要列举出每一条路线并分别计算出相应的费用即可。从中就可以找出最小费用及对应的路线。 
 例3 货郎担问题 
 <编号> 
 输入：城市个数n，费用矩阵c[][] 
 输出：旅行路线t[]，最小费用min 
 Void salesman_problem(int n, 
 float c[ ][ ],t[ ],float &min) 
 { float cost; 
 int p[n]; 
 min=maxCost; 
 while(i<=n!) { 
 产生n个城市的排列于p; 
 cost = 路线p的费用; 
 if(cost<min){ 
 p数组内容送t; 
 min = cost; } 
 i++; 
 } 
 } 
 n 
 n! 
 6 
 720 μs 
 9 
 362ms 
 10 
 3.62s 
 13 
 1.72h 
 16 
 242days 
 20 
 77146years 
 分析：假定每执行一次需要1μs。 
 <编号> 
 算法学习能够培养学生的逻辑思维能力 
 求解：ax + b = 0 
 理由3 
 <编号> 
 解决实际问题： 
 自驾游； 
 装修材料选择； 
 …… 
 理由4 
 <编号> 
 Chris McKinlay， UCLA（加利福尼亚大学洛杉矶分校） 
 OkCupid 
 1.利用12个账户基于Python的脚本自动搜索； 
 2.编写一软件模拟人的点击率和打字速度来欺骗OkCupid； 
 3.收集到了600多个问题的答案，数据来自全美的数万个女性； 
 4. McKinlay选择了贝尔实验室的K-Modes算法来给这些女人分类； 
 5. 根据这些分类获得相应的喜好，提出了“perfect”自己，提高匹配度； 
 6. 写了个程序，自动在对方的主页上踩下痕迹（超匹配+被踩过）； 
 7. 开始一一约会，A组的女人约会不太成功（通过算法分析到A组的女人，常常会有很多纹身，并且多居住在洛杉矶东面），转向B组； 
 8. 附加“约会守则”：约会都定在下午而不要一起吃饭；一天可以约会两个对象；不去看电影或者听音乐会……（与算法无关。。。）； 
 9. 第89次约会，真爱到来。。。Christine Tien Wang，UCLA master； 
 10. 编个程序，让计算机帮他们挑个黄道吉日来举行婚礼； 
 理由5 
 <编号> 
 理由5 
 Optimal Cupid: Mastering the Hidden Logic of OkCupid 
 http://christophermckinlay.net/ 
 <编号> 
 ① 设计算法 
 ② 表示算法 
 ③ 确认算法 
 ④ 分析算法 
 ⑤ 验证算法 
 问题2 算法课程学习什么？ 
问题2 学习内容
 <编号> 
 第1章 算法引论 
 第2章 递归与分治策略 
 第3章 动态规划 
 第4章 贪心算法 
 第5章 回溯法 
 第6章 分支限界法 
主要内容（续）
 <编号> 
 第8章 NP完全性理论 
 第9章 近似算法 
 第10章 算法优化策略 
问题3 如何学习本课程？
 不能仅停留在代码和程序等表现上，要追根溯源，学习并掌握算法设计的方法，独立进行算法设计，解决实际问题 。 
 参考书目 
 1. 《算法导论》Thomas H.Cormen, Charles E.Leiserson, Ronald L.Rivest, Clifford Stein著 
 2. 《算法与数据结构》，王晓东 
 <编号> 
第1章 算法引论
 <编号> 
▪ 1.1 算法与程序 
▪ 1.2 表达算法的抽象机制 
▪ 1.3 描述算法 
▪ 1.4 算法复杂性分析 
 本章主要知识点： 
1.1 算法与程序
 <编号> 
▪ 输 入：有零个或多个外部量作为算法的输入。 
▪ 输 出：算法产生至少一个量作为输出。 
▪ 确定性：组成算法的每条指令清晰、无歧义。 
▪ 有限性：算法中每条指令的执行次数有限，执行每条指令的时间也有限。 
 是算法用某种程序设计语言的具体实现。 
 程序可以不满足算法的性质(4)即有限性。 
 是满足下述性质的指令序列。 
 算法： 
 程序： 
 <编号> 
 算法的描述方法可以归纳为以下几种： 
 (1) 自然语言； (2) 图形，如流程图，图的描述与算法语言的描述对应； (3) 算法语言，即计算机语言、程序设计语言、伪代码； (4) 形式语言，用数学的方法，可以避免自然语言的二义性。 
 1.3 描述算法 
1.4 算法复杂性分析
 <编号> 
 算法复杂性是算法运行所需要的计算机资源的量， 
 需要时间资源的量称为时间复杂性，需要的空间资源的 
 量称为空间复杂性。 
 这个量应该只依赖于算法要解的问题的规模、算法的输入和算法本身的函数。 
 <编号> 
 假设： N—规模 
 I —输入 
 A —算法 
 C —复杂性 
 则：C=F(N,I,A) 
 则：时间复杂性T=T(N,I,A) 
 空间复杂性S=S(N,I,A) 
 又算法本生是确定的，T和S可简化为: 
 T=T(N,I) 
 S=S(N,I) 
 
 <编号> 
 T=T(N,I)复杂性函数具体化： 
 假设元运算有k种，记为：O1, O2,… OK. 
 执行元运算所需时间分别为：t1, t2,… tk. 
 Oi运算次数为ei ； 则T(N,I)＝∑ ti ei 
 T=T(N,I)简化仅仅与规模有关。 
 Ei统计的复杂性 
 <编号> 
```java
Algorithm lcsLength(x,y,b) 
 1: mx.length-1; 
 2: ny.length-1; 
 3: c[i][0]=0; c[0][i]=0; 
 4: for (int i = 1; i <= m; i++) 
 5: for (int j = 1; j <= n; j++) 
 6: if (x[i]==y[j]) 
 7: c[i][j]=c[i-1][j-1]+1; 
 8: b[i][j]=1; 
 9: else if (c[i-1][j]>=c[i][j-1]) 
 10: c[i][j]=c[i-1][j]; 
 11: b[i][j]=2; 
 12: else 
 13: c[i][j]=c[i][j-1]; 
 14: b[i][j]=3; 
```

1.4 算法复杂性分析
 <编号> 
 最坏情况下的时间复杂性： 
 最好情况下的时间复杂性： 
 平均情况下的时间复杂性： 
 其中DN是规模为N的合法输入的集合；I*是DN中使T(N, I*) 
 达到Tmax(N)的合法输入； 是中使 达到Tmin(N)的合法 
 输入；而P(I)是在算法的应用中出现输入 I 的概率。 
 <编号> 
 函数的渐进性态与渐进表达式：设T(N)是关于算法A的复杂性函数。 
 一般来说，当N单调增加且趋于∞时，T(N)也将单调增加趋于∞。 
 对于T(N)，如果存在函数T'(N)，使得当N→ ∞使有(T(N)-T'(N))/T(N) →0，那么我们就说T'(N)是T(N)当N→ ∞时的渐进性态。 
 在数学上，T'(N)是T(N)当N→ ∞时的渐进表达式。 
 例如：3N2+4NlogN+7与3N2。 
 1.4 算法复杂性分析 
 <编号> 
 O定义：对所有N，f(N)  0，g(N)  0，如果存在常数C和自然数N0，使得当N≥ N0时: f(N)≤Cg(N)，称f(N)的阶至多是O(g(N))。即：f(N)当N充分大时有界，g(N) 是其上界，记为f(N) ＝O(g(N)) 
 渐近意义下的记号：O、Ω、θ、o 
 设f(N)和g(N)是定义在正数集上的正函数。 
 算法复杂性在渐近意义下的阶 
 例： f(n) ＝20n2+9n+33 
 取n0＝10，则对∨nn0 , f(n) 21n2 
 令c＝21， g(n) ＝ n2 
 有： f(n)  cn2 ＝ cg(n) 
 所以： f(n)＝O(g(n))=O(n2) 
O的运算规则
 <编号> 
 根据O的定义，容易证明它有如下运算规则： 
 (1)O(f)+O(g)=O(max(f, g))； 
 (2)O(f)+O(g)=O(f+g)；（证明） 
 (3)O(f)O(g)=O(fg)； 
 (4)如果g(N)=O(f(N))，则O(f)+O(g)=O(f)； 
 (5)O(Cf(N))=O(f(N))，其中C是一个正的常数； 
 (6)f = O(f)。 
1.4 算法复杂性分析
 <编号> 
 Ω的定义：如果存在正的常数C和自然数N0，使得当NN0时 
 有f(N)Cg(N)，则称函数f(N)当N充分大时下有界，且g(N)是它 
 的一个下界，记为f(N)=Ω(g(N))。即f(N)的阶不低于g(N)的阶。 
 例: f(n)=5n+2 
 令n0=0, 当n  n0时，有c1＝5，g(n)=n,使得： 
 f(n)  5n＝c1g(n) 
 所以f(n)＝  (g(n) )= (n) 
 
 <编号> 
 θ的定义：定义f(N)= θ(g(N))当且仅当f(N)=O(g(N))且 
 f(N)= Ω(g(N))。此时称f(N)与g(N)同阶。 
 o的定义：对于任意给定的ε＞0，都存在正整数N0，使得 
 当N N0时有f(N)/Cg(N)ε,则称函数f(N)当N充分大时的阶比 
 g(N)低，记为f(N)=o(g(N))。 
 例如，4NlogN+7=o(3N2+4NlogN+7)。 
 例: f(n)=5n+2 
 令n0=0, 当n  n0时，有c1＝5，g(n)=n,使得： 
 f(n)  5n＝c1g(n) 
 所以f(n)＝  (g(n) )= (n) 
 令n0=2, 当n  n0时，有c2＝6，g(n)=n,使得： 
 f(n)  5n＋n＝6n＝c2g(n) 
 所以f(n)＝ O(g(n) )=O (n) 所以f(n)= θ (n) 
 <编号> 
 算法分析中常见的复杂性函数 
 <编号> 
 小规模数据复杂性增长图 
 <编号> 
 中等规模数据复杂性增长图 
 <编号> 
 非递归算法： 
 （1）for / while 循环 
 循环体内计算时间*循环次数； 
 （2）嵌套循环 
 循环体内计算时间*所有循环次数； 
 （3）顺序语句 
 各语句计算时间相加； 
 （4）if-else语句 
 if 语句计算时间和 else 语句计算时间的较大者。 
 算法分析的基本法则 
 <编号> 
 问题的计算时间下界为(f(n))，则计算时间复杂性为O(f(n))的算法是最优算法。 
 例如，排序问题的计算时间下界为(nlogn)，计算时间复杂性为O(nlogn)的排序算法是最优算法。 
 堆排序算法是最优算法。 
 最优算法 
 <编号> 
 证明正确性 
 分析算法 
 设计程序 
 理解问题 
 精确解或近似解 
 选择数据结构 
 算法设计策略 
 设计算法 
 小结 
 算法与程序的区别 
 算法设计 
 算法分析 
