
# 第3章 动态规划

## 3.1 动态规划的起源

20世纪50年代初，美国数学家R.E. Bellman等人在研究多阶段决策过程（multistep decision process）的优化问题时，提出了著名的最优化原理（principle of optimality）。他们将多阶段过程转化为一系列单阶段问题，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。

## 3.2 动态规划的应用

自问世以来，动态规划在经济管理、生产调度、工程技术和最优控制等方面得到了广泛的应用，包括但不限于：

- 最短路线
- 库存管理
- 资源分配
- 设备更新
- 排序
- 装载问题

使用动态规划方法比使用其他方法求解这些问题更为方便和高效。

## 3.3 多阶段决策过程

在N个输入的最优解问题中，活动过程通常划分为若干阶段。每一阶段的决策依赖于前一阶段的状态，决策所采取的动作会导致状态转移，成为下一阶段的依据。

```
阶段1 (P1) → 状态0 (S0)
阶段2 (P2) → 状态1 (S1)
阶段3 (P3) → 状态2 (S2)
...
阶段n (Pn) → 状态n-1 (Sn-1)
最终状态 (Sn)
```

## 3.4 最优性原理

**贝尔曼 (Richard Bellman)** 提出了最优性原理：

- 无论过程的初态和初始决策是什么，其余的决策必须相对于初始决策所产生的状态，构成一个最优决策序列。
- 每一阶段的决策都有多种选择，但只有一种决策对全局是最优的。

### 3.4.1 最优性原理的详细说明

假设对于一种状态可以作出多种决策，而每一种决策可以产生一种新状态，根据最优原理：

- 对初态 `S0`，决策集 `P1 = {p1,1, p1,2, …, p1,r1}` 会产生状态 `S1 = {S1,1, S1,2, …, S1,r1}`。决策集合作为阶段子问题保存。
- 依此类推，对于状态 `Sn-1 = {Sn-1,1, Sn-1,2, …, Sn-1,rn-1}`，决策集 `Pn = {Pn-1,1, Pn-1,2, …, Pn-1,rn-1}`。
- 其中只有一种状态是最优的，假设为 `Sn,kn`，由决策 `Pn,kn` 产生。故 `Pn,kn` 为最优决策。

最终，通过回溯可以得到最优决策序列 `{P1,k1, P2,k2, …, Pn,kn}`，导致状态转移序列 `{S0, S1,k1, S2,k2, …, Sn,kn}`。

## 3.5 动态规划函数

在决策过程中，有一个赖以决策的策略或目标，这个策略或目标称为决策函数。整个决策过程可以递归进行，或用循环迭代的方法进行。

## 3.6 货郎担问题

### 3.6.1 问题描述

对n个城市，用编号1～n表示，问题归结为：

在有向赋权图 `G=<V, E>` 中，寻找一条路径最短的哈密尔顿回路问题。

- `V = {1,2,…,n}` 表示城市顶点。
- 边 `(i,j) ∈ E` 表示城市 `i` 到城市 `j` 的距离。
- 用邻接矩阵 `C` 表示各城市间距离：
  - 如果 `(i,j) ∈ E`，则 `Cij > 0` 且 `Cij` 是固定值；
  - 否则 `Cij = ∞`。

令 `d(i, V')` 表示从顶点 `i` 出发，经过 `V'` 中各个顶点一次，最终回到 `i` 的最短路径长度。初始时，令 `V' = V - {i}`。

### 3.6.2 动态规划函数

假定有4个城市，其费用矩阵如下：

|   | 1 | 2 | 3 | 4 |
|---|---|---|---|---|
| 1 | ∞ | 3 | 5 | ∞ |
| 2 | 6 | 2 | ∞ | 5 |
| 3 | 7 | 3 | 2 | ∞ |
| 4 | ∞ | 5 | ∞ | ∞ |

最短路径长度为：
```
d(1, {2,3,4}) = min{ c12 + d(2, {3,4}), c13 + d(3, {2,4}), c14 + d(4, {2,3}) } = 10
```

### 3.6.3 动态规划递归关系

```
d(i, V') = min { c(i,k) + d(k, V' - {k}) } for all k ∈ V'
```

### 3.6.4 算法复杂度分析

- 设 `ni` 为计算 `d(k, V - {k})` 的个数，`k != i`。
- 当 `V - {k}` 集合中城市个数为 `j` 时，计算 `d(k, V - {k})` 需要 `j` 次加法和 `j-1` 次比较运算。
- 总运算时间为 `O(n^2)`。

### 3.6.5 实际应用

许多实际问题可以归结为货郎担问题，例如：

1. 物资运输路线中，汽车应走的最短路线。
2. 工厂中自动焊接机割咀的最短路径。
3. 城市中管道铺设的最优路线。
4. 旅行社选择的最佳旅行线路。

## 3.7 矩阵连乘问题

### 3.7.1 问题描述

给定n个矩阵 `{A1, A2, …, An}`，其中 `Ai` 与 `Ai+1` 是可乘的，`i=1,2,…,n-1`。考察这n个矩阵的连乘积 `A1 A2 ... An`。

由于矩阵乘法满足结合律，矩阵连乘可以有多种不同的计算次序。这种计算次序可以用加括号的方式来确定。

**例子**：

设有四个矩阵：

- `A1 = 50 × 10`
- `A2 = 10 × 40`
- `A3 = 40 × 30`
- `A4 = 30 × 5`

共有五种完全加括号的方式：

1. `(A1((A2 A3) A4))` → 16000 次乘法
2. `(((A1 A2) A3) A4)` → 10500 次乘法
3. `(A1(A2(A3 A4)))` → 36000 次乘法
4. `((A1(A2 A3)) A4)` → 87500 次乘法
5. `((A1 A2)(A3 A4))` → 34500 次乘法

### 3.7.2 动态规划解决方案

**递归关系**：

```
m[i][j] = min { m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j] } for all i ≤ k < j
```

其中，`Ai` 的维数为 `pi-1 × pi`。

**最优子结构**：

计算 `A[i:j]` 的最优计算次序包含了 `A[i:k]` 和 `A[k+1:j]` 的最优计算次序。

**代码实现**:

```java
public class MatrixChainOrder {
    public static void matrixChain(int[] p, int[][] m, int[][] s) {
        int n = p.length - 1;

        // 初始化m[i][i] = 0
        for (int i = 1; i <= n; i++) {
            m[i][i] = 0;
        }

        // l为链长
        for (int l = 2; l <= n; l++) {
            for (int i = 1; i <= n - l + 1; i++) {
                int j = i + l - 1;
                m[i][j] = Integer.MAX_VALUE;
                for (int k = i; k < j; k++) {
                    int q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
                    if (q < m[i][j]) {
                        m[i][j] = q;
                        s[i][j] = k;
                    }
                }
            }
        }
    }

    // 构造最优解
    public static void Traceback(int i, int j, int[][] s) {
        if (i == j) {
            System.out.print("A" + i);
            return;
        }
        System.out.print("(");
        Traceback(i, s[i][j], s);
        Traceback(s[i][j] + 1, j, s);
        System.out.print(")");
    }

    public static void main(String[] args) {
        int[] p = {50, 10, 40, 30, 5};
        int n = p.length - 1;
        int[][] m = new int[n + 1][n + 1];
        int[][] s = new int[n + 1][n + 1];

        matrixChain(p, m, s);
        System.out.println("最少乘法次数为: " + m[1][n]);
        System.out.print("最优加括号方式为: ");
        Traceback(1, n, s);
    }
}
```

**复杂度分析**:

- **时间复杂度**: `O(n³)`
- **空间复杂度**: `O(n²)`

### 3.7.3 构造最优解

利用表格 `s[i][j]` 来记录每个子问题的分割位置，通过回溯构造最优解。

```java
public static void Traceback(int i, int j, int[][] s) {
    if (i == j) {
        System.out.print("A" + i);
        return;
    }
    System.out.print("(");
    Traceback(i, s[i][j], s);
    Traceback(s[i][j] + 1, j, s);
    System.out.print(")");
}
```

**示例输出**:

```
最少乘法次数为: 10500
最优加括号方式为: ((A1A2)A3)A4
```

## 3.8 最长公共子序列 (LCS)

### 3.8.1 问题定义

- **定义1**: 若给定序列 `X = {x1, x2, …, xm}`，则另一序列 `Z = {z1, z2, …, zk}` 是 `X` 的子序列，若存在一个严格递增的下标序列 `{i1, i2, …, ik}` 使得对于所有 `j = 1, 2, …, k`，有 `zj = xij`。
  - 例如：序列 `Z = {B, C, D, B}` 是序列 `X = {A, B, C, B, D, A, B}` 的子序列，相应的递增下标序列为 `{2, 3, 5, 7}`。
  
- **定义2**: 给定两个序列 `X` 和 `Y`，当另一序列 `Z` 既是 `X` 的子序列又是 `Y` 的子序列时，称 `Z` 是序列 `X` 和 `Y` 的公共子序列。

**问题描述**: 给定两个序列 `X = {x1, x2, …, xm}` 和 `Y = {y1, y2, …, yn}`，找出 `X` 和 `Y` 的最长公共子序列。

### 3.8.2 最长公共子序列的结构

设序列 `Xm = {x1, x2, …, xi}` 和 `Yn = {y1, y2, …, yj}` 的最长公共子序列为 `Zk = {z1, z2, …, zk}` (k ≤ m, n)，则：

1. 若 `xm = yn`，则 `zk = xm = yn`，且 `Zk-1` 是 `Xm-1` 和 `Yn-1` 的最长公共子序列。
2. 若 `xm ≠ yn` 且 `zk ≠ xm`，则 `Zk` 是 `Xm-1` 和 `Yn` 的最长公共子序列。
3. 若 `xm ≠ yn` 且 `zk ≠ yn`，则 `Zk` 是 `Xm` 和 `Yn-1` 的最长公共子序列。

由此可见，两个序列的最长公共子序列包含了这两个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有最优子结构性质。

### 3.8.3 递归关系

设 `c[i][j]` 为序列 `Xm = {x1, x2, …, xi}` 和 `Yn = {y1, y2, …, yj}` 的最长公共子序列的长度。则：

```
c[i][j] =
    0, if i = 0 or j = 0
    c[i-1][j-1] + 1, if xi = yj
    max(c[i][j-1], c[i-1][j}), if xi ≠ yj
```

### 3.8.4 动态规划求解

**步骤**:

1. **初始化**: 当 `i = 0` 或 `j = 0` 时，`c[i][j] = 0`。
2. **填表**: 按照递归关系填充 `c[i][j]` 表格。
3. **构造最优解**: 从 `c[m][n]` 回溯，构造出最长公共子序列。

**代码实现**:

```java
public class LCS {
    public static int[][] lcsLength(String X, String Y) {
        int m = X.length();
        int n = Y.length();
        int[][] c = new int[m + 1][n + 1];

        // 初始化
        for (int i = 0; i <= m; i++) {
            c[i][0] = 0;
        }
        for (int j = 0; j <= n; j++) {
            c[0][j] = 0;
        }

        // 填表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (X.charAt(i - 1) == Y.charAt(j - 1)) {
                    c[i][j] = c[i - 1][j - 1] + 1;
                } else {
                    c[i][j] = Math.max(c[i - 1][j], c[i][j - 1]);
                }
            }
        }

        return c;
    }

    // 构造最长公共子序列
    public static String traceback(int i, int j, int[][] c, String X, String Y) {
        if (i == 0 || j == 0) {
            return "";
        }
        if (X.charAt(i - 1) == Y.charAt(j - 1)) {
            return traceback(i - 1, j - 1, c, X, Y) + X.charAt(i - 1);
        } else {
            if (c[i - 1][j] > c[i][j - 1]) {
                return traceback(i - 1, j, c, X, Y);
            } else {
                return traceback(i, j - 1, c, X, Y);
            }
        }
    }

    public static void main(String[] args) {
        String X = "abcbdab";
        String Y = "acbbcbab";
        int[][] c = lcsLength(X, Y);
        System.out.println("最长公共子序列长度为: " + c[X.length()][Y.length()]);
        System.out.println("最长公共子序列为: " + traceback(X.length(), Y.length(), c, X, Y));
    }
}
```

**示例输出**:

```
最长公共子序列长度为: 4
最长公共子序列为: abcb
```

### 3.8.5 算法的改进

在算法 `lcsLength` 和 `traceback` 中，可以进一步优化空间：

- **省略数组 `b`**: 数组 `c[i][j]` 的值仅由 `c[i-1][j-1]`、`c[i-1][j]` 和 `c[i][j-1]` 确定，因此无需额外的数组来记录方向。
- **空间优化**: 如果只需要计算最长公共子序列的长度，算法的空间需求可大大减少。实际上，只需使用两行数组空间 `O(min(m, n))`。

## 3.9 流水作业调度

### 3.9.1 问题描述

有 `n` 个作业 `{1, 2, …, n}` 要在由两台机器 `M1` 和 `M2` 组成的流水线上完成加工。每个作业的加工顺序都是先在 `M1` 上加工，然后在 `M2` 上加工。机器 `M1` 和 `M2` 加工作业 `i` 所需的时间分别为 `ai` 和 `bi`。

**目标**: 确定作业的最优加工顺序，使得从第一个作业在 `M1` 上开始加工，到最后一个作业在 `M2` 上加工完成所需的时间最少。

### 3.9.2 最优性原理

设 `π` 是作业集 `S` 在机器 `M2` 的等待时间为 `t` 时的一个最优调度，所需的加工时间为 `ai + T(S - {i}, bi)`。则动态规划递归关系如下：

```
T(S, t) = min { ai + T(S - {i}, bi + max{ t - ai, 0 }) } for all i ∈ S
```

**最优子结构**: `T(n, c) = min { a_i + T(n - {i}, b_i) }`

### 3.9.3 Johnson不等式与Johnson法则

**Johnson不等式**:

当作业 `i` 和作业 `j` 满足 `min{bi, aj} ≥ min{bj, ai}`，则称作业 `i` 和 `j` 满足Johnson不等式。

**Johnson法则**:

- **步骤**:
  1. **划分作业**:
     - `N1 = {i | ai < bi}`
     - `N2 = {i | ai ≥ bi}`
  2. **排序作业**:
     - 将 `N1` 中的作业按 `ai` 的非减序排序。
     - 将 `N2` 中的作业按 `bi` 的非增序排序。
  3. **合并序列**:
     - 将 `N1` 中排序后的作业接在 `N2` 中排序后的作业之前，构成满足Johnson法则的最优调度。

**复杂度分析**:

- **时间复杂度**: `O(n log n)`，主要耗时在排序步骤。
- **空间复杂度**: `O(n)`

**示例**:

```
作业编号: 1  2  3  4  5  6
ai:       5  1  8  5  3  4
bi:       7  2  2  4  7  5
```

**应用Johnson法则**:

1. 划分作业:
   - `N1 = {2, 5, 6}` (因为 `a2=1 < b2=2`, `a5=3 < b5=7`, `a6=4 < b6=5`)
   - `N2 = {1, 3, 4}` (因为 `a1=5 ≥ b1=7`, `a3=8 ≥ b3=2`, `a4=5 ≥ b4=4`)

2. 排序:
   - `N1` 按 `ai` 非减序排序: `2, 5, 6`
   - `N2` 按 `bi` 非增序排序: `1, 5, 3`

3. 合并序列:
   - 最优调度: `2, 5, 6, 1, 4, 3`

**最优调度时间**: 28

## 3.10 0-1背包问题

### 3.10.1 问题描述

给定 `n` 种物品和一个背包。物品 `i` 的重量是 `wi`，其价值为 `vi`，背包的容量为 `C`。问如何选择装入背包的物品，使得装入背包中物品的总价值最大？

**数学模型**:

```
最大化 Σ vi * xi
s.t. Σ wi * xi ≤ C,  for all i = 1, 2, ..., n
xi ∈ {0, 1},  for all i = 1, 2, ..., n
```

### 3.10.2 最优子结构性质

0-1背包问题具有最优子结构性质。

**证明**:

设 `(y1, y2, …, yn)` 是所给0-1背包问题的一个最优解，则 `(y2, …, yn)` 是下面相应子问题的一个最优解：

```
最大化 Σ vi * yi
s.t. Σ wi * yi ≤ C - w1 * y1,  for all i = 2, 3, ..., n
yi ∈ {0, 1},  for all i = 2, 3, ..., n
```

### 3.10.3 递归关系

设 `m(i, j)` 为前 `i` 个物体中，能够装入载重量为 `j` 的背包中的物体的最大价值。

```
m(i, j) =
    0, if i = 0 or j = 0
    max { m(i-1, j), m(i-1, j-wi) + vi }, if wi ≤ j
    m(i-1, j), otherwise
```

### 3.10.4 动态规划求解

**步骤**:

1. **初始化**: 当 `i = 0` 或 `j = 0` 时，`m[i][j] = 0`。
2. **填表**: 按照递归关系填充 `m[i][j]` 表格。
3. **构造最优解**: 从 `m[n][C]` 回溯，确定哪些物品被装入背包。

**代码实现**:

```java
public class Knapsack {
    public static int[][] knapsack(int[] v, int[] w, int C, int n) {
        int[][] m = new int[n + 1][C + 1];

        // 初始化
        for (int i = 0; i <= n; i++) {
            m[i][0] = 0;
        }
        for (int j = 0; j <= C; j++) {
            m[0][j] = 0;
        }

        // 填表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= C; j++) {
                if (j >= w[i - 1]) {
                    m[i][j] = Math.max(m[i - 1][j], m[i - 1][j - w[i - 1]] + v[i - 1]);
                } else {
                    m[i][j] = m[i - 1][j];
                }
            }
        }

        return m;
    }

    // 构造最优解
    public static void traceback(int[][] m, int[] w, int n, int C, int[] x) {
        int j = C;
        for (int i = n; i > 0; i--) {
            if (m[i][j] > m[i - 1][j]) {
                x[i - 1] = 1;
                j -= w[i - 1];
            }
        }
    }

    public static void main(String[] args) {
        int n = 5;
        int C = 10;
        int[] w = {2, 2, 6, 5, 4};
        int[] v = {6, 3, 5, 4, 6};
        int[] x = new int[n];

        int[][] m = knapsack(v, w, C, n);
        traceback(m, w, n, C, x);

        System.out.println("最优价值为: " + m[n][C]);
        System.out.print("最优解为: ");
        for (int i = 0; i < n; i++) {
            System.out.print(x[i] + " ");
        }
    }
}
```

**示例输出**:

```
最优价值为: 10
最优解为: 1 1 0 0 1 
```

**复杂度分析**:

- **时间复杂度**: `O(nC)`
- **空间复杂度**: `O(nC)`

### 3.10.5 动态规划算法的基本步骤

1. **找出最优解的性质，并刻划其结构特征**。
2. **递归地定义最优值（建立递归关系）**。
3. **以自底向上的方式计算出最优值**。
4. **根据计算最优值时得到的信息，构造最优解**。

## 3.11 动态规划小结

通过以上论述，我们可以发现，对于常见的最优化问题，动态规划的算法思想是最佳的解决方法。它将问题实例归纳为更小的、相似的子问题，并通过求解子问题产生一个全局最优解。

**优点**:

- 结构清晰，易于理解和实现。
- 可读性强，便于使用数学归纳法证明算法的正确性。
- 提高了算法效率，尤其是在处理具有重叠子问题的问题时。

**缺点**:

- 动态规划的空间复杂度较高，尤其是二维或多维表格的情况。
- 需要满足最优子结构和无后效性等特征，限制了其适用范围。

**解决方法**:

1. **消除递归**: 将递归算法转化为非递归算法。
2. **使用栈模拟**: 采用用户定义的栈模拟系统的递归调用栈。
3. **递推实现**: 用递推方式实现递归函数。
4. **尾递归优化**: 通过尾递归优化，将递归转化为迭代，提升效率。

**总结**:

- 动态规划是一种强大的算法设计技术，适用于许多具有自相似结构和重叠子问题的优化问题。
- 在设计动态规划算法时，需确保递归终止条件明确，避免无限递归。
- 优化动态规划算法可以显著提升其性能，尤其是在处理大规模问题时。

## 3.12 动态规划与分治法的比较

**相同点**:

- 动态规划和分治法都将问题实例归纳为更小的、相似的子问题，并通过求解子问题产生一个全局最优解。

**不同点**:

- **子问题独立性**:
  - **分治法**: 各个子问题是独立的（不包含公共子子问题）。
  - **动态规划**: 子问题之间可能包含公共的子子问题，具有重叠子问题性质。
  
- **重复计算**:
  - **分治法**: 在解决过程中可能会重复计算相同的子问题。
  - **动态规划**: 通过存储子问题的解，避免重复计算，提升效率。
  
- **应用场景**:
  - **分治法**: 适用于子问题独立且不重叠的情况。
  - **动态规划**: 适用于具有重叠子问题和最优子结构性质的情况。

**总结**:

动态规划与分治法在算法设计中各有优势，选择使用哪种方法取决于问题的具体特性。动态规划通过利用重叠子问题和最优子结构性质，能够在许多复杂的最优化问题中提供高效的解决方案。

---