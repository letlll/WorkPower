# 学习数据结构和算法 |DSA 教程【自用】

****数据结构和算法 （DSA）**** 是指对组织和存储数据的方法的研究以及解决问题的过程（算法）的设计，这些程序对这些数据结构进行操作。DSA 是每个计算机科学学生必须具备的最重要的技能之一。人们经常看到，对这些技术有充分了解的人比其他人更擅长程序员，因此，几乎破解了所有科技巨头的采访，包括谷歌、Microsoft、亚马逊和 Facebook（现在的 Meta）等公司。本 DSA 教程旨在帮助您快速轻松地学习数据结构和算法 （DSA）。

数据结构与算法教程

目录

- [DSA 简介](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#introduction-to-dsa)
- [了解 Compliities](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#1-learn-about-complexities)
- [数组](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#4-array)
- [矩阵/网格](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#5-matrixgrid)
- [字符串](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#6-string)
- [叠](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#6-stack)
- [队列](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#7-queue)
- [递归](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#7-recursion)
- [回溯算法](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#8-backtracking-algorithm)
- [分而治之算法](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#9-divide-and-conquer-algorithm)
- [搜索和排序算法](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#11-searching-and-sorting-algorithms)
- [链表](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#10-linked-lists)
- [散 列](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#15-hash)
- [树](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#16-tree)
- [堆](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#17-heap)
- [图](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#18-graph)
- [贪婪算法](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#19-greedy-algorithms)
- [动态规划](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#20-dynamic-programming)
- [图形算法](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#22-graph-algorithms)
- [模式搜索](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#22-pattern-searching)
- [分支和边界算法](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#23-branch-and-bound-algorithm)
- [几何算法](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#24-geometric-algorithms)
- [随机算法](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#25-randomized-algorithms)
- [练习题作弊表](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/?ref=home-articlecards16-tree#practice-problem-cheat-sheets)

## DSA 简介

****数据结构和算法 （DSA）**** 是计算机科学的基础，可帮助我们有效地组织和处理数据。它们用于解决常见的软件挑战，从管理大型数据集到优化任务速度。以下是 DSA 必不可少的原因：

- DSA 有助于有效地存储和管理数据，使其在需要时更易于检索和使用。
- 无论是在 GPS 系统中查找最短路径，还是在搜索引擎中优化搜索结果，DSA 在解决此类问题方面都发挥着重要作用。
- 通过了解 DSA，您可以更有效地设计系统，这在 Web 应用程序、数据库和机器学习等领域非常重要。

掌握 DSA 不仅对开发高质量软件很重要，而且对职业发展也很重要。****Google、Microsoft、Amazon、Apple、Meta**** 和许多其他公司等顶级公司在面试中都非常关注****数据结构和算法****。学习 DSA 将提高您解决问题的能力，并使您在当今竞争激烈的技术世界中成为更强大的程序员。

### [如何学习 DSA？](https://www.geeksforgeeks.org/how-to-start-learning-dsa/)

首先也是最重要的事情是将整个过程分成需要按顺序完成的小块。从头开始学习 DSA 的完整过程可以分为 5 个部分：

1. 至少学习一门编程语言（我们留给您选择。
2. 学习数据结构
3. 学习算法
4. 了解时间和空间的复杂性
5. [DSA 练习题](https://www.geeksforgeeks.org/explore?page=1&sortBy=submissions&itm_source=geeksforgeeks&itm_medium=main_header&itm_campaign=practice_header)

![5-Steps-to-learn-DSA-from-scratch](https://media.geeksforgeeks.org/wp-content/uploads/20240917121350/5-Steps-to-learn-DSA-from-scratch.webp)

希望您已经学习了自己选择的编程语言，让我们在本 DSA 教程中继续下一步学习 DSA。

这是学习数据结构和算法路线图中最重要和最期待的阶段——您开始学习 DSA 的阶段。

DSA 主题由两部分组成：

- [****数据结构****](https://www.geeksforgeeks.org/data-structures/)
- [****算法****](https://www.geeksforgeeks.org/fundamentals-of-algorithms/)

虽然它们是两件不同的事情，但它们是高度相互关联的，遵循正确的轨道以最有效地学习它们非常重要。如果您对先学习哪一个感到困惑，我们建议您阅读我们关于以下主题的详细分析：[****我应该先学习什么 - 数据结构或算法？****](https://www.geeksforgeeks.org/what-should-i-learn-first-data-structures-or-algorithms/)

## 1. [了解复杂性](https://www.geeksforgeeks.org/complete-guide-on-complexity-analysis/)

在数据结构和算法 （DSA） 中，主要目标是有效且高效地解决问题。为了确定程序的效率，我们查看两种类型的复杂性：

1. [Time Complexity](https://www.geeksforgeeks.org/time-complexity-and-space-complexity/)：这告诉我们代码运行需要多长时间。
2. [Space Complexity](https://www.geeksforgeeks.org/time-complexity-and-space-complexity/)：这告诉我们代码使用了多少内存。

### [渐近表示法](https://www.geeksforgeeks.org/asymptotic-notations-and-how-to-calculate-them/)

为了比较算法的效率，我们使用渐近表示法，这是一种数学工具，可以根据 ****输入大小****估计****时间****，而无需运行代码。它侧重于程序中基本操作的数量。

|表示法|描述|
|---|---|
|[大 O （Ο）](https://www.geeksforgeeks.org/analysis-algorithms-big-o-analysis/)|描述最坏情况，提供算法的时间上限。|
|[欧米茄 （Ω）](https://www.geeksforgeeks.org/analysis-of-algorithms-big-omega-notation/)|描述最佳情况，提供算法的下限时间。|
|[θ （θ）](https://www.geeksforgeeks.org/analysis-of-algorithms-big-theta-notation/)|表示 algorithm 的 algorithm 的平均复杂度。|

代码分析最常用的表示法是 Big O 表示法，它提供与输入大小相关的运行时间或内存使用量的上限。

****相关主题：****

- [通过简单的示例了解时间复杂度](https://www.geeksforgeeks.org/understanding-time-complexity-simple-examples/)
- [不同数据结构的时间复杂度](https://www.geeksforgeeks.org/time-complexities-of-different-data-structures/)
- [如何分析循环以进行算法的复杂性分析](https://www.geeksforgeeks.org/how-to-analyse-loops-for-complexity-analysis-of-algorithms/)
- [时间复杂度分析练习题](https://www.geeksforgeeks.org/practice-questions-time-complexity-analysis/)

## 2. 数学和按位算法

### 1[.数学算法](https://www.geeksforgeeks.org/mathematical-algorithms/)

****数学算法****是一类解决与数学概念相关的问题的算法。它们广泛用于各个领域，包括计算机图形学、数值分析、优化和密码学。

|算法|描述|
|---|---|
|[GCD](https://www.geeksforgeeks.org/program-to-find-gcd-or-hcf-of-two-numbers/) 和 [LCM](https://www.geeksforgeeks.org/lcm-of-given-array-elements/)|求两个数字的最大公约数和最小公倍数。|
|[质因数分解](https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/)|将一个数字分解为其质因数。|
|[斐波那契数列](https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/)|生成斐波那契数列，其中每个数字是前两个数字之和。|
|[加泰罗尼亚语数字](https://www.geeksforgeeks.org/program-nth-catalan-number/)|计算具有给定括号对数的有效表达式的数量。|
|[模算术](https://www.geeksforgeeks.org/modular-arithmetic/)|对给定值取模的数字执行算术运算。|
|[Euler Totient 函数](https://www.geeksforgeeks.org/eulers-totient-function/)|计算小于给定数字的正整数的数量，这些正整数相对于它来说是素数。|
|[nCr 计算](https://www.geeksforgeeks.org/program-calculate-value-ncr/)|计算二项式系数，它表示从一组 n 个元素中选择 r 个元素的方法数。|
|[素数和原初检验](https://www.geeksforgeeks.org/introduction-to-primality-test-and-school-method/)|确定给定数是否为素数并有效地找到素数。|
|[Sieve 算法](https://www.geeksforgeeks.org/sieve-of-eratosthenes/)|找到达到给定极限的所有素数。|

****相关主题：****

- [数学算法练习题](https://www.geeksforgeeks.org/explore?page=1&category=Mathematical&sortBy=submissions)

### 2. [按位算法](https://www.geeksforgeeks.org/bitwise-algorithms/)

****按位算法****是对单个数字位进行操作的算法。这些算法处理数字的二进制表示形式以执行诸如位操作、按位逻辑运算（AND、OR、XOR****）、移位****以及****设置****或清除数字中的****特定位****等任务。按位算法通常用于 需要有效操作单个位的****低级编程、加密和优化任务****。

|主题|描述|
|---|---|
|[位移位](https://www.geeksforgeeks.org/left-shift-right-shift-operators-c-cpp/)|将位向左或向右移动指定数量的位置。|
|[左移 （<<）](https://www.geeksforgeeks.org/left-shift-right-shift-operators-c-cpp/)|向左移动位，有效地将数字乘以 2。|
|[右移 （>>）](https://www.geeksforgeeks.org/left-shift-right-shift-operators-c-cpp/)|将位向右移动，有效地将数字除以 2。|
|[提取位](https://www.geeksforgeeks.org/extract-k-bits-given-position-number/)|使用掩码从整数中提取特定位。|
|[设置位](https://www.geeksforgeeks.org/set-k-th-bit-given-number/)|使用 masks 将特定位设置为整数中的 1。|
|[清理位](https://www.geeksforgeeks.org/program-to-clear-k-th-bit-of-a-number-n/)|使用 masks 将特定位设置为整数中的 0。|
|[切换位](https://www.geeksforgeeks.org/toggling-k-th-bit-number/)|使用 XOR （^） 切换整数中的特定位。|
|[计数 Set 位](https://www.geeksforgeeks.org/count-set-bits-in-an-integer/)|计算整数中 set bits （1s） 的数量。|

****相关主题：****

- [按位算法教程](https://www.geeksforgeeks.org/introduction-to-bitwise-algorithms-data-structures-and-algorithms-tutorial/)
- [按位算法练习题](https://www.geeksforgeeks.org/explore?page=1&category=Bit%20Magic&sortBy=submissions)

## 3. [数组](https://www.geeksforgeeks.org/array-data-structure/)

****Array**** 是一种线性数据结构，用于存储相同数据类型的元素集合。元素被分配了连续内存，允许恒定时间访问。每个元素都有一个唯一的索引号。

- [****对数组的操作：****](https://www.geeksforgeeks.org/search-insert-and-delete-in-an-unsorted-array/)
    - ****遍历****：遍历数组的元素。
    - ****Insertion****：将元素添加到数组中的特定索引处。
    - ****Deletion****：从数组中删除特定索引处的元素。
    - ****搜索****：按值或索引在数组中查找元素。
- [****数组类型****](https://www.geeksforgeeks.org/types-of-arrays/)****：****
    - ****一维数组****：具有单个维度的简单数组。
    - ****多维数组****：具有多个维度的数组，例如矩阵。
- [****Array 的应用****](https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-array-data-structure/)****：****
    - 按顺序存储数据
    - 实现队列、堆栈和其他数据结构
    - 表示矩阵和表
- ****数组的相关主题：****
    - [数组教程](https://www.geeksforgeeks.org/introduction-to-arrays-data-structure-and-algorithm-tutorials/)
    - [面试的 50 大数组编码问题](https://www.geeksforgeeks.org/top-50-array-coding-problems-for-interviews/)
    - [数组上的练习题](https://www.geeksforgeeks.org/explore?page=1&category[]=Arrays)

## 4. [矩阵/网格](https://www.geeksforgeeks.org/matrix/)

****矩阵****是元素的二维数组，按行和列排列。它表示为矩形网格，每个元素位于行和列的交集处。

- ****关键概念：****
    - ****行****：矩阵中元素的水平线。
    - ****列****：矩阵中元素的垂直线。
    - ****维度****：矩阵中的行数和列数（例如，3×4 矩阵有 3 行和 4 列）。
    - ****元素********访问****：可以使用行和列索引访问元素（例如，M[2][3] 是指第 2 行第 3 列中的元素）。
- ****矩阵/网格的应用****：
    - 图像处理
    - 数据分析
    - 优化问题
- ****相关文章：****
    - [矩阵/网格教程](https://www.geeksforgeeks.org/introduction-to-matrix-or-grid-data-structure-and-algorithms-tutorial/)
    - [Matrix/Grid 上面试的前 50 个问题](https://www.geeksforgeeks.org/top-50-matrix-grid-coding-problems-for-interviews/)
    - [Matrix/Grid 上的练习题](https://www.geeksforgeeks.org/explore?page=1&category=Matrix&sortBy=submissions)

## 5. [字符串](https://www.geeksforgeeks.org/string-data-structure/)

****字符串****是字符序列，通常用于表示文本。它被认为是一种允许在计算机程序中操作和处理文本数据的数据类型。

- [****对 String 的操作****](https://www.geeksforgeeks.org/basic-string-operations-with-implementation/)****：****
    - ****Concatenation****：将两个字符串连接在一起。
    - ****比较****：按字典顺序比较两个字符串。
    - ****Substring**** ****extraction****：从字符串中提取子字符串。
    - ****Search****：在字符串中搜索子字符串。
    - ****修改****：更改或替换字符串中的字符。
- [****字符串的应用****](https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-string/)****：****
    - 文本处理
    - 模式匹配
    - 数据验证
    - 数据库管理
- ****相关文章：****
    - [字符串教程](https://www.geeksforgeeks.org/introduction-to-strings-data-structure-and-algorithm-tutorials/)
    - [面试的 50 大字符串编码问题](https://www.geeksforgeeks.org/top-50-string-coding-problems-for-interviews/)
    - [弦乐练习题](https://www.geeksforgeeks.org/string-data-structure/#standard)

## 6. [堆栈](https://www.geeksforgeeks.org/stack-data-structure/)

****堆栈****是一种线性数据结构，它遵循执行操作的特定顺序。顺序可以是 ****LIFO（后进先出）****或 ****FILO（先进后出）。**** ****LIFO**** 表示最后插入的元素先出现，****FILO**** 表示首先插入的元素最后出现。

- [****堆栈操作****](https://www.geeksforgeeks.org/basic-operations-in-stack-data-structure-with-implementations/)****：****
    - ****Push****：将元素添加到堆栈顶部
    - ****Pop****：删除并返回堆栈顶部的元素
    - ****Peek****：返回堆栈顶部的元素，而不删除它
    - ****大小****：返回堆栈中的元素数
    - ****IsEmpty****：检查堆栈是否为空
- [****堆栈的应用****](https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-stack/)****：****
    - 函数调用
    - 表达式评估
    - 回溯
    - 撤消/重做操作
- ****Stack 上的相关主题：****
    - [堆栈教程](https://www.geeksforgeeks.org/introduction-to-stack-data-structure-and-algorithm-tutorials/)
    - [Stack 上面试的前 50 个问题](https://www.geeksforgeeks.org/top-50-problems-on-stack-data-structure-asked-in-interviews/)
    - [Stack 上的练习题](https://www.geeksforgeeks.org/explore?page=1&category[]=Stack)

## 7. [队列](https://www.geeksforgeeks.org/introduction-to-queue-data-structure-and-algorithm-tutorials/)

****队列****数据结构是计算机科学中的一个基本概念，用于按特定顺序存储和管理数据。它遵循“****先进先出****”（****FIFO）**** 原则，其中添加到队列的第一个元素是第一个被删除的元素

- [****对队列的操作****](https://www.geeksforgeeks.org/basic-operations-for-queue-in-data-structure/)****：****
    - ****Enqueue****：将元素添加到队列的后面
    - ****Dequeue****：从队列前面删除元素
    - ****Peek****：检索 front 元素而不将其删除
    - ****IsEmpty****：检查队列是否为空
    - ****IsFull****：检查队列是否已满
- [****队列类型****](https://www.geeksforgeeks.org/different-types-of-queues-and-its-applications/)****：****
    - [循环队列](https://www.geeksforgeeks.org/introduction-to-circular-queue/)：最后一个元素连接到第一个元素
    - [双端队列 （Deque）：](https://www.geeksforgeeks.org/deque-set-1-introduction-applications/)可以从两端执行操作
    - [Priority Queue](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/)：根据优先级排列元素
- [****Queue 的应用****](https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-queue/)****：****
    - 作业调度
    - 消息排队
    - 仿真建模
    - 数据缓冲
- ****相关主题：****
    - [队列教程](https://www.geeksforgeeks.org/introduction-to-queue-data-structure-and-algorithm-tutorials)
    - [面试队列中的前 50 个问题](https://www.geeksforgeeks.org/top-50-problems-on-queue-data-structure-asked-in-sde-interviews/)
    - [在 Queue 上练习问题](https://www.geeksforgeeks.org/explore?page=1&category[]=Queue)

## 8. [递归](https://www.geeksforgeeks.org/recursion-algorithms/)

****递归****是一种编程技术，其中函数在其自己的定义中调用自身。它通常用于解决可以分解为同一问题的较小实例的问题。****例如：****[河内塔 （TOH）、](https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/)[阶乘计算](https://www.geeksforgeeks.org/program-for-factorial-of-a-number/)和[斐波那契数列](https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/)等。

****步骤****：

- ****基本情况****：定义停止递归调用并提供解决方案的条件。
- ****Recursive Case****：定义将问题分解为较小实例并进行递归调用的步骤。
- ****Return****：返回递归调用的解决方案，并将它们组合起来以解决原始问题。

使递归成为最常用的算法之一的一点是，它构成了许多其他算法的基础，例如****树遍历、图形遍历、分而治之算法****和****回溯算法。****

****相关主题：****

- [递归教程](https://www.geeksforgeeks.org/introduction-to-recursion-data-structure-and-algorithm-tutorials/)
- [递归函数](https://www.geeksforgeeks.org/recursive-functions/)
- [尾递归](https://www.geeksforgeeks.org/tail-recursion/)
- [面试递归算法的 50 大问题](https://www.geeksforgeeks.org/top-50-interview-problems-on-recursion-algorithm/)
- [递归算法的练习题](https://www.geeksforgeeks.org/explore?page=1&category[]=Recursion)

## 9. [回溯算法](https://www.geeksforgeeks.org/backtracking-algorithms/)

如前所述，****Backtracking**** 算法源自 Recursion 算法，如果递归解决方案失败，则可以选择恢复，即如果解决方案失败，程序将追溯到它失败的时刻并建立在另一个解决方案之上。所以基本上它会尝试所有可能的解决方案并找到正确的解决方案。

在继续之前，您必须解决的回溯算法的一些重要和最常见的问题是：

|问题|描述|
|---|---|
|[Knight 的游览问题](https://www.geeksforgeeks.org/the-knights-tour-problem/)|在棋盘上找到一个骑士的一系列移动，使其恰好访问每个方格一次。|
|[迷宫中的老鼠](https://www.geeksforgeeks.org/rat-in-a-maze/)|在迷宫中找到从起始位置到出口的路径，障碍物表示为墙壁。|
|[N-Queen 问题](https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/)|将 N 个皇后放在 N×N 个棋盘上，这样就不会有两个皇后互相攻击。|
|[子集和问题](https://www.geeksforgeeks.org/subset-sum-problem/)|确定是否存在具有给定总和的给定集的子集。|
|[数独](https://www.geeksforgeeks.org/sudoku-backtracking-7/)|解决一个 9×9 网格的谜题，其中包含从 1 到 9 的数字，使得每一行、每一列和 3×3 子网格都包含所有数字，没有重复。|

****相关文章：****

- [回溯教程](https://www.geeksforgeeks.org/introduction-to-backtracking-data-structure-and-algorithm-tutorials/)
- [回溯算法的练习题](https://www.geeksforgeeks.org/explore?page=1&category[]=Backtracking)

## 10. [分而治之算法](https://www.geeksforgeeks.org/divide-and-conquer/)

****分而治之****算法遵循递归策略来解决问题，方法是将问题划分为更小的子问题，解决这些子问题，然后将解决方案组合起来以获得最终解决方案。

****步骤：****

1. ****Divide****：将问题划分为更小的独立子问题。
2. ****征服****：递归解决每个子问题。
3. ****Combine****：合并子问题的解，得到最终的解。

****例子：****

- Merge Sort：将数组分为两半，递归地对每半进行排序，并合并已排序的两半。
- 快速排序：选择一个枢轴元素，根据枢轴将数组划分为两个子数组，并递归地对每个子数组进行排序。

****相关文章：****

- [分而治之教程](https://www.geeksforgeeks.org/introduction-to-divide-and-conquer-algorithm-data-structure-and-algorithm-tutorials/)
- [Divide And Conquer 算法的练习题](https://www.geeksforgeeks.org/explore?page=1&category[]=Divide%20and%20Conquer)

## 11. 搜索和排序算法

### 1[.排序算法](https://www.geeksforgeeks.org/sorting-algorithms/)

****排序算法****用于按特定顺序排列列表的元素，例如数字或字母顺序。它以系统的方式组织项目，从而更容易搜索和访问特定元素。

有很多不同类型的排序算法。一些广泛使用的算法是：

|排序算法|描述|
|---|---|
|[冒泡排序](https://www.geeksforgeeks.org/bubble-sort/)|迭代比较相邻元素，如果它们的顺序不正确，则交换它们。每次传递时，最大的元素会“冒泡”到列表的末尾。|
|[选择排序](https://www.geeksforgeeks.org/selection-sort/)|在列表的未排序部分查找最小元素，并将其与第一个元素交换。重复此过程，直到对整个列表进行排序。|
|[插入排序](https://www.geeksforgeeks.org/insertion-sort/)|通过将每个未排序的元素插入到排序部分中的正确位置，一次构建一个元素的排序列表。|
|[快速排序](https://www.geeksforgeeks.org/quick-sort/)|一种分而治之算法，用于选择透视元素，根据透视将列表划分为两个子列表，并递归地将相同的过程应用于子列表。|
|[归并排序](https://www.geeksforgeeks.org/merge-sort/)|另一种分而治之算法，以递归方式将列表划分为更小的子列表，对它们进行排序，然后将它们合并在一起以获得排序列表。|

****相关主题：****

- [排序算法教程](https://www.geeksforgeeks.org/introduction-to-sorting-algorithm/)
- [热门排序面试问题和问题](https://www.geeksforgeeks.org/top-sorting-interview-questions-and-problems/)
- [排序算法练习题](https://www.geeksforgeeks.org/explore?page=1&category[]=Sorting)

### 2[.搜索算法](https://www.geeksforgeeks.org/searching-algorithms/)

****搜索算法****用于在更大的数据集中查找特定数据。它有助于查找数据中是否存在目标值。有各种类型的搜索算法，每种算法都有自己的方法和效率。

- ****最常见的搜索算法：****
    - [线性搜索](https://www.geeksforgeeks.org/linear-search/)：从一端到另一端的迭代搜索。
    - [Binary Search](https://www.geeksforgeeks.org/binary-search/)：对排序数组进行分而治之的搜索，在每次迭代时将搜索空间减半。
    - [Ternary Search](https://www.geeksforgeeks.org/ternary-search/)：对排序数组进行分而治之的搜索，在每次迭代时将搜索空间分为三个部分。
- ****其他搜索算法：****
    - [跳转搜索](https://www.geeksforgeeks.org/jump-search/)
    - [插值搜索](https://www.geeksforgeeks.org/interpolation-search/) 
    - [指数搜索](https://www.geeksforgeeks.org/exponential-search/) 
- ****相关主题：****
    - [搜索算法练习题](https://www.geeksforgeeks.org/explore?page=1&category[]=Searching)

## 12. [链表](https://www.geeksforgeeks.org/data-structures/linked-list/)

****链表****是一种线性数据结构，它将数据存储在节点中，这些节点由指针连接。与数组不同，链表不存储在连续的内存位置。

- ****链表的特点：****
    - ****动态****：可以通过添加或删除节点来轻松调整链表的大小。
    - ****Non-contiguous****：节点存储在随机的内存位置，并通过指针连接。
    - ****顺序访问****：节点只能从列表的头部开始按顺序访问。
- ****链表操作：****
    - ****创建****：创建新的链表或向现有列表添加新节点。
    - ****遍历****：遍历列表并访问每个节点。
    - ****Insertion****：在列表中的特定位置添加新节点。
    - ****Deletion****：从列表中删除节点。
    - ****搜索****：在列表中查找具有特定值的节点。
- [****链表的类型****](https://www.geeksforgeeks.org/types-of-linked-list/)****：****
    - [单向链表](https://www.geeksforgeeks.org/data-structures/linked-list/singly-linked-list/)：每个节点都指向列表中的下一个节点。
    - [双向链表](https://www.geeksforgeeks.org/data-structures/linked-list/doubly-linked-list/)：每个节点都指向列表中的下一个和上一个节点。
    - [循环链表](https://www.geeksforgeeks.org/circular-linked-list/)：最后一个节点指向第一个节点，形成一个循环。
- [****链表的应用****](https://www.geeksforgeeks.org/applications-of-linked-list-data-structure/)****：****
    - 链表用于各种应用程序，包括：
    - 实施队列和堆栈
    - 表示图形和树
    - 维护有序数据
    - 内存管理
- ****相关主题：****
    - [链表教程](https://www.geeksforgeeks.org/introduction-to-linked-list-data-structure-and-algorithm-tutorial/)
    - [访谈链表上的前 50 个问题](https://www.geeksforgeeks.org/top-20-linked-list-interview-question/)
    - [链表上的练习题](https://www.geeksforgeeks.org/explore?page=1&category[]=Linked%20List)

## 13. [哈希](https://www.geeksforgeeks.org/hashing-data-structure/)

****哈希是一种****使用称为哈希****函数****的数学公式从可变大小的输入生成固定大小输出（哈希值）的技术。哈希用于确定在数据结构中存储项目的索引或位置，从而实现高效的检索和插入。

- ****关键概念：****
    - [哈希函数](https://www.geeksforgeeks.org/hash-functions-and-list-types-of-hash-functions/)：将输入映射到哈希值的数学函数。
    - [哈希表](https://www.geeksforgeeks.org/hash-table-data-structure/)：一种存储键值对的数据结构，其中键是哈希值，值是实际数据。
    - [Collision](https://www.geeksforgeeks.org/collision-resolution-techniques/)：当两个不同的 key 产生相同的哈希值时。
- [****哈希函数的类型****](https://www.geeksforgeeks.org/hash-functions-and-list-types-of-hash-functions/)****：****
    - ****除法****：将输入除以一个常数，并将余数用作哈希值。
    - ****中间平方****法：对输入进行平方，并将中间数字作为哈希值。
    - ****折叠方法****：将输入分成大小相等的块，然后将它们相加得到哈希值。
    - ****乘法****：将输入乘以一个常数，并将小数部分作为哈希值。

- [****碰撞解决技术****](https://www.geeksforgeeks.org/collision-resolution-techniques/)****：****
    - [Separate Chaining （Open Hashing）：](https://www.geeksforgeeks.org/separate-chaining-collision-handling-technique-in-hashing/)将冲突元素存储在相应哈希值的链接列表中。
    - [Open Addressing （Closed Hashing）：](https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/)使用各种策略为哈希表中的冲突元素寻找替代位置。
- [****哈希的应用****](https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-hash-data-structure/)****：****
    - 在数据库和文件系统中高效存储和检索数据。
    - 验证密码和数字签名。
    - 在多个服务器之间分发请求。
    - 为数据完整性和身份验证生成安全哈希。
- ****相关文章：****
    - [哈希教程](https://www.geeksforgeeks.org/introduction-to-hashing-data-structure-and-algorithm-tutorials/)
    - [哈希练习题](https://www.geeksforgeeks.org/explore?page=1&category=Hash&sortBy=submissions)

## 14. [树](https://www.geeksforgeeks.org/tree-data-structure/)

****树****是一种非线性分层数据结构，由由边连接的节点组成，其中顶部节点称为根，节点具有子节点。它在计算机科学中用于有效地组织数据。

- [****Tree 遍历****](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)****：****Tree 遍历方法用于访问和处理 Tree 数据结构中的节点。三种常见的遍历方法是：
    - [按顺序](https://www.geeksforgeeks.org/inorder-traversal-of-binary-tree/)：访问左侧子树、当前节点，然后访问右侧子树。
    - [预购](https://www.geeksforgeeks.org/preorder-traversal-of-binary-tree/)：访问当前节点，先访问左子树，再访问右子树。
    - [后排序](https://www.geeksforgeeks.org/post-order-traversal-of-binary-tree-in-on-using-o1-space/)：访问左子树、右子树，然后访问当前节点。
- ****树木分类：****
    - 树木分类 是指根据某些特征或标准对树木进行分组。这可能涉及根据树的平衡因子、节点程度、排序属性等对树进行分类。以下是 Tree 的一些重要分类。

|分类|描述|类型|描述|
|---|---|---|---|
|按度数|可以根据每个节点可以具有的最大子项数对树进行分类。|[****二叉树****](https://www.geeksforgeeks.org/binary-tree-data-structure/)|每个节点最多有两个子节点。|
|[****三元树****](https://www.geeksforgeeks.org/ternary-tree/)|每个节点最多有三个子节点。|
|[****N-ary 树****](https://www.geeksforgeeks.org/generic-tree-or-n-ary-tree/)|每个节点最多有 N 个子节点。|
|按订购|可以根据节点和子树的顺序对树进行分类|[****二叉搜索树 （BST）****](https://www.geeksforgeeks.org/binary-search-tree-data-structure/)|每个节点的 Left child < parent < right child。|
|[****堆****](https://www.geeksforgeeks.org/heap-data-structure/)|具有 heap 属性的专用二叉树。|
|按余额|可以根据树木的平衡程度对树木进行分类。|[****平衡树****](https://www.geeksforgeeks.org/balanced-binary-tree/)|子树的高度最多相差 1。示例包括 AVL 树和红黑树。|
|****不平衡树****|子树的高度可能会有很大差异，从而影响搜索和插入等操作的性能。|

- [****树木的应用：****](https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-tree/)
    - 文件系统
    - 数据库
    - XML 文档
    - 人工智能
- ****相关文章：****
    - [树教程](https://www.geeksforgeeks.org/introduction-to-tree-data-structure-and-algorithm-tutorials/)
    - [前 50 个树编码问题](https://www.geeksforgeeks.org/top-50-tree-coding-problems-for-interviews/)
    - [在 Tree 上练习题](https://www.geeksforgeeks.org/explore?page=1&category[]=Tree)

## 15. [堆](https://www.geeksforgeeks.org/heap-data-structure/)

****Heap**** 是满足 HEAP 属性的完整二叉树数据结构：对于每个节点，其 children 的值小于或等于其自身的值。堆通常用于实现[****优先级队列****](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/)，其中最小（或最大）元素始终位于树的根。

- [****堆的操作****](https://www.geeksforgeeks.org/insertion-and-deletion-in-heaps/)****：****
    - ****Insert****：在维护堆属性的同时向堆添加新元素。
    - ****Extract-Max/Extract-Min****：删除根元素并重新构建堆。
    - ****Increase/Decrease - Key****：更新节点的值并重组堆。
- [****堆的类型****](https://www.geeksforgeeks.org/types-of-heap-data-structure/)****：****
    - [Max-Heap](https://www.geeksforgeeks.org/introduction-to-max-heap-data-structure/)：根节点在其子节点中具有最大值。
    - [Min-Heap](https://www.geeksforgeeks.org/introduction-to-min-heap-data-structure/)：根节点在其子节点中具有最小值。
- [****堆的应用****](https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-heap/)****：****
    - 优先级队列
    - 排序
    - 图形算法（例如，Dijkstra 算法）
- ****相关文章：****
    - [堆教程](https://www.geeksforgeeks.org/introduction-to-heap-data-structure-and-algorithm-tutorials/)
    - [Heap 上最适合访谈的 50 个问题](https://www.geeksforgeeks.org/top-50-problems-on-heap-data-structure-asked-in-interviews/)
    - [在堆上练习问题](https://www.geeksforgeeks.org/explore?page=1&category=Heap&sortBy=submissions)

## 16. [图表](https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/)

****Graph**** 是一种非线性数据结构，由一组有限的顶点（或节点）和一组连接一对节点的边组成。

- ****图的遍历：****
    - [广度优先搜索 （BFS）：](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/)逐级访问节点。
    - [深度优先搜索 （DFS）：](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/)递归访问节点，一次探索一个分支。
- [****图的应用****](https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-graph/)****：****
    - 社交网络
    - 地图和导航
    - 调度
    - 数据挖掘
- ****相关文章：****
    - [图形表示](https://www.geeksforgeeks.org/graph-and-its-representations/)
    - [图表类型](https://www.geeksforgeeks.org/graph-types-and-applications/)
    - [图形教程](https://www.geeksforgeeks.org/introduction-to-graphs-data-structure-and-algorithm-tutorials/)
    - [Graph 上的练习题](https://www.geeksforgeeks.org/explore?page=1&category[]=Graph)

## 19. [贪婪算法](https://www.geeksforgeeks.org/introduction-to-greedy-algorithm-data-structures-and-algorithm-tutorials/)

顾名思义，该算法一次构建一个解决方案，然后选择下一个提供最明显和直接好处的部分，即，这是当时最优化的选择。因此，选择局部最优也会导致全局解的问题最适合 Greedy。

贪婪算法的一些重要问题是：

|算法|描述|
|---|---|
|[分数背包](https://www.geeksforgeeks.org/fractional-knapsack-problem/)|查找可以放入背包中的物品的最大总价值，允许部分包含物品。|
|[Dijkstra 算法](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)|查找从源顶点到加权图中所有其他顶点的最短路径。|
|[Kruskal 算法](https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/)|查找加权图的最小跨度树。|
|[霍夫曼编码](https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/)|为一组符号创建最佳前缀代码，从而最小化总编码长度。|

****相关文章：****

- [贪婪算法教程](https://www.geeksforgeeks.org/introduction-to-greedy-algorithm-data-structures-and-algorithm-tutorials/)
- [贪婪算法练习题](https://www.geeksforgeeks.org/explore?page=1&category[]=Greedy)

## 17. [动态规划](https://www.geeksforgeeks.org/introduction-to-dynamic-programming-data-structures-and-algorithm-tutorials/)

****动态规划****是数学和计算机科学中使用的一种方法，通过将复杂问题分解为更简单的子问题来解决这些问题。通过仅求解每个子问题一次并存储结果，它避免了冗余计算，从而为各种问题提供了更高效的解决方案。

****关键概念：****

- [最优子结构](https://www.geeksforgeeks.org/optimal-substructure-property-in-dynamic-programming-dp-2/)：问题的最优解可以从其子问题的最优解中构建。
- [重叠的子问题](https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/)：子问题通常在较大的问题中重复出现，从而导致冗余计算。
- [Memoization](https://www.geeksforgeeks.org/what-is-memoization-a-complete-tutorial/) / [Tabulation](https://www.geeksforgeeks.org/tabulation-vs-memoization/)：存储子问题的解决方案以避免重新计算。

在继续之前，您必须解决的动态规划算法的一些重要和最常见的问题是：

|问题|描述|
|---|---|
|[斐波那契数列](https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/)|使用动态规划生成斐波那契数列，以避免重复计算。|
|[最长公共 Subsequence](https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/)|求两个序列共有的最长子序列。|
|[最长递增的子序列](https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/)|查找给定序列的最长子序列，其中元素按升序排序。|
|[0/1 背包问题](https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/)|确定通过选择具有给定权重和值的项目（不超过指定的重量限制）可以获得的最大值。|
|[杆切割问题](https://www.geeksforgeeks.org/cutting-a-rod-dp-13/)|通过将给定长度的棒切割成小块并根据给定的价格出售来最大化利润。|
|[硬币兑换问题](https://www.geeksforgeeks.org/coin-change-dp-7/)|确定使用一组给定面额的硬币对给定数量进行兑换的方法数量。|
|[编辑距离](https://www.geeksforgeeks.org/edit-distance-dp-5/)|查找将一个字符串转换为另一个字符串所需的最小操作数 （插入、删除、替换）。|
|[子集和问题](https://www.geeksforgeeks.org/subset-sum-problem-dp-25/)|确定是否存在具有给定总和的给定集的子集。|
|[最长回文子序列](https://www.geeksforgeeks.org/longest-palindromic-subsequence-dp-12/)|找到给定序列的最长子序列，即回文。|
|[最大子数组总和](https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/)|在给定的一维数组中查找具有最大和的连续子数组。|
|[分区等于子集和](https://www.geeksforgeeks.org/partition-set-k-subsets-equal-sum/)|确定是否可以将给定集划分为两个总和相等的子集。|
|[最低成本路径](https://www.geeksforgeeks.org/minimum-cost-path-left-right-bottom-moves-allowed/)|查找从给定网格的左上角到右下角的最低成本路径。|
|[最大 Product Subarray](https://www.geeksforgeeks.org/maximum-product-subarray/)|查找给定一维数组中具有最大乘积的连续子数组。|

****相关文章：****

- [制表 vs 记忆化](https://www.geeksforgeeks.org/tabulation-vs-memoizatation/)
- [如何解决动态规划问题？](https://www.geeksforgeeks.org/solve-dynamic-programming-problem/)
- [动态规划教程](https://www.geeksforgeeks.org/introduction-to-dynamic-programming-data-structures-and-algorithm-tutorials/)
- [面试的 50 大动态规划编码问题](https://www.geeksforgeeks.org/top-50-dynamic-programming-coding-problems-for-interviews/)
- [动态规划算法的练习题](https://www.geeksforgeeks.org/explore?page=1&category[]=Dynamic%20Programming)

## 18. [图算法](https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/)

数据结构和算法 （DSA） 中的图形算法是一组用于解决与图形相关的问题的技术和方法，图形是节点和边缘的集合。这些算法旨在对图形执行各种操作，例如****搜索、遍历、查找最短路径****和确定****连通性****。它们对于解决各种实际问题（包括网络路由、社交网络分析和资源分配）至关重要。

|主题|主题描述|算法|算法描述|
|---|---|---|---|
|****图遍历****|访问图形中所有顶点的技术。|[深度优先搜索 （DFS）](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/)|在回溯之前，沿着每个分支尽可能深入地探索。|
|[广度优先搜索 （BFS）](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/)|在移动到下一级别的顶点之前浏览相邻顶点。|
|****最小跨度树****|最小生成树是连接图形中所有节点而不形成循环的最小树，通过添加尽可能短的边来实现。|[Kruskal 算法](https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/)|它查找连通加权图的最小跨度树。它增加了不形成循环的最小权重边。|
|[Prim 算法](https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/)|它还查找连通加权图的最小生成树。它添加了连接两棵树的最小权重边。|
|****拓扑排序****|拓扑排序是有向无环图 （DAG） 中顶点的线性排序，因此，对于从顶点 u 到顶点 v 的每个有向边，u 在排序中排在 v 之前。|[Kahn 算法](https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/)|Kahn 算法找到有向无环图 （DAG） 的拓扑排序。|
|[基于 DFS 的算法](https://www.geeksforgeeks.org/topological-sorting/)|基于 DFS 的算法使用深度优先搜索在有向无环图 （DAG） 中执行拓扑排序。|
|****最短路径****|图形中的最短路径是图形中两个顶点之间的路径，与相同两个顶点之间的所有其他路径相比，该路径沿其边的权重总和最小。|[Dijkstra 算法](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)|贪婪算法，在 O（E * V logV） 时间内找到所有节点之间的最短路径。|
|[Floyd-Warshall 算法](https://www.geeksforgeeks.org/floyd-warshall-algorithm-dp-16/)|查找以 O（V^3） 时间表示的所有节点对之间的最短路径。|
|[Bellman Ford 算法](https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/)|在 O（V * E） 时间内查找从单个源开始的最短路径。|
|[Johnson 算法](https://www.geeksforgeeks.org/johnsons-algorithm/)|在 O（V^2 logV + V * E） 时间内查找所有顶点对之间的最短路径。|
|****强连接组件****|有向图的强连接分量 （SCC） 是一组最大顶点，使得从集合中的每个顶点到集合中的每个其他顶点都有一条路径。|[Kosaraju 算法](https://www.geeksforgeeks.org/strongly-connected-components/)|Kosaraju 算法是一种两遍算法，可有效地找到有向图的强连接分量 （SCC）。|
|[Tarjan 算法](https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/)|Tarjan 算法是另一种在有向图中查找 SCC 的有效算法|

****相关主题：****

- [图形教程](https://www.geeksforgeeks.org/introduction-to-graphs-data-structure-and-algorithm-tutorials/)
- [面试的 50 大图形编码问题](https://www.geeksforgeeks.org/top-50-graph-coding-problems-for-interviews/)
- [图算法练习题](https://www.geeksforgeeks.org/explore?page=1&category=Graph&sortBy=submissions)

## 19[.模式搜索](https://www.geeksforgeeks.org/algorithms-gq/pattern-searching/)

****模式搜索****是 DSA 中的一种基本技术，用于在给定文本中查找特定模式的出现。

以下是一些标准的模式搜索算法：

|算法|描述|时间复杂度|
|---|---|---|
|[蛮力](https://www.geeksforgeeks.org/searching-for-patterns-set-1-naive-pattern-searching/)|它将模式与文本的每个子字符串进行比较|O（百万）|
|[克努斯-莫里斯-普拉特](https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/)|它使用预先计算的 failure 函数来跳过不必要的比较|O（米 + n）|
|[博耶-摩尔](https://www.geeksforgeeks.org/boyer-moore-algorithm-for-pattern-searching/)|它从右到左比较模式，根据最后一个不匹配跳过字符|O（百万）|
|[拉宾-卡普](https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/)|它使用哈希来快速检查潜在的匹配项|O（米 + n）|

****相关主题：****

- [模式搜索教程](https://www.geeksforgeeks.org/introduction-to-pattern-searching-data-structure-and-algorithm-tutorial/)
- [模式搜索](https://www.geeksforgeeks.org/explore?page=1&category=Pattern%20Searching&sortBy=submissions)[练习题](https://www.geeksforgeeks.org/explore?page=1&category=Pattern%20Searching&sortBy=submissions)

## 20. [分支和边界算法](https://www.geeksforgeeks.org/branch-and-bound-algorithm/)

****Branch and Bound Algorithm**** 是组合优化问题中使用的一种方法，用于系统地搜索最佳解决方案。它的工作原理是将问题划分为更小的子问题或分支，然后根据最佳解决方案的边界消除某些分支。此过程一直持续，直到找到最佳解决方案或探索了所有分支。

分支和边界算法的标准问题：

|独特问题|描述|
|---|---|
|[使用 Branch 和 Bound 的 0/1 背包](https://www.geeksforgeeks.org/0-1-knapsack-using-branch-and-bound/)|用于解决 0/1 背包问题的分支和边界方法的实现细节。|
|[使用 Least Cost Branch 和 Bound 的 0/1 背包](https://www.geeksforgeeks.org/0-1-knapsack-using-least-count-branch-and-bound/)|使用成本最低的分支和绑定技术解决 0/1 背包问题。|
|[8 拼图使用 Branch 和 Bound 的问题](https://www.geeksforgeeks.org/8-puzzle-problem-using-branch-and-bound/)|应用分支和绑定解决 8 拼图问题，一款流行的滑动益智游戏。|
|[使用 Branch 和 Bound 的 N Queen 问题](https://www.geeksforgeeks.org/n-queen-problem-using-branch-and-bound/)|利用 branch 和 bound 找到 N Queens 问题的解决方案，这是一个经典的国际象棋问题。|

****相关主题：****

- [分支和边界算法教程](https://www.geeksforgeeks.org/introduction-to-branch-and-bound-data-structures-and-algorithms-tutorial/)

## 21. [几何算法](https://www.geeksforgeeks.org/geometric-algorithms/)

****几何算法****是一类解决与几何相关的问题的算法。几何算法对于解决计算机科学中的各种问题至关重要，例如：

|算法|描述|
|---|---|
|[凸包](https://www.geeksforgeeks.org/convex-hull-algorithm/)|查找包含一组点的最小凸多边形。|
|[最近的点对](https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/)|查找集中彼此最接近的两个点。|
|[线交点](https://www.geeksforgeeks.org/program-for-point-of-intersection-of-two-lines/)|确定两条线是否相交，如果相交，则查找交点。|
|[多边形中的点](https://www.geeksforgeeks.org/how-to-check-if-a-given-point-lies-inside-a-polygon/)|确定给定点是位于多边形内部还是外部。|

****相关主题：****

- [几何算法练习题](https://www.geeksforgeeks.org/explore?page=1&category=Geometric&sortBy=submissions)

## 22. [随机算法](https://www.geeksforgeeks.org/randomized-algorithms/)

随机算法是使用随机性解决问题的算法。他们利用随机输入来实现他们的目标，通常会导致更简单或更有效的解决方案。

****随机算法的类型：****

- [Las Vegas](https://www.geeksforgeeks.org/randomized-algorithms-set-2-classification-and-applications/)：始终生成正确的结果，但运行时间是随机的。
- [Monte Carlo](https://www.geeksforgeeks.org/randomized-algorithms-set-2-classification-and-applications/)：可能会以较小的概率产生不正确的结果，但运行时间通常更快。

****使用随机化算法的重要算法：****

|算法|描述|
|---|---|
|[快速排序](https://www.geeksforgeeks.org/quick-sort/)|一种随机排序算法，平均情况时间复杂度为 O（n log n）。|
|[跳过列表](https://www.geeksforgeeks.org/skip-list/)|一种随机数据结构，可提供快速搜索和插入操作。|
|[布隆过滤器](https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/)|用于高效集合成员资格测试的概率数据结构。|

## 练习题作弊表

以下文章中的问题精选列表：

- [Sandeep Jain 的 DSA 路线图](https://www.geeksforgeeks.org/dsa-roadmap-for-beginner-to-advanced-by-sandeep-jain/)
- [SDE 表 – SDE 准备完整指南](https://www.geeksforgeeks.org/sde-sheet-a-complete-guide-for-sde-preparation/)
- [GeeksforGeeks 主表 – 所有作弊表列表](https://www.geeksforgeeks.org/geeksforgeeks-master-sheet-list-of-all-cheat-sheets/)